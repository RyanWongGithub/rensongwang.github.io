---
title: 排序-堆排序
tags:
  - 算法
categories:
  - 数据结构与算法
date: 2019-07-08 17:07:51
photo:
---

{% note default %}
堆这种数据结构其实十分巧妙，它的巧妙在于它本身是一个完全二叉树。但是它一般是在数组上实现的，也就是说，不像链表一般要存储多余的指针，而是通过完全二叉树的特性结合数组下标来巧妙实现。
堆排序的时间复杂度特别稳定，也是原地排序，但是为什么还是选择优先快排？
{% endnote %}

<!-- more -->

## what
首先，什么是堆？堆是一种数据结构，准确地来说，堆是在数组上实现的完全二叉树。
- 堆是一棵完全二叉树。
- 堆的任何结点都大于等于(或小于等于)其左右子结点。

## how
因为完全二叉树的特殊性，我们可以通过数组的下标来代表指针进行树的结点之间的**隐形连接**。
如果从数组下标0开始存储结点。那么：
- 左子结点的下标是2\*i+1，右子结点的下标为2\*i+2。
- 父结点的下标为(i-1)/2。
如果从下标1开始存储结点，以此类推。

## more
堆一般的操作有两种，插入数据和**删除堆顶元素**。
但是插入或删除了数据，我们必须要维护堆的特性。
于是，就有了**堆化**。顾名思义，就是使其变成堆。
堆化有两种方式，一种使从下往上，一种是从上往下。
一般插入数据会采用从下往上的方式，一般就是插到数组尾部，然后与其父结点比较交换，一直到堆顶。
而删除堆顶元素要特别注意维护堆的特性，不能产生数组空洞。
所以，一般的做法是将堆顶元素与数组的最后一个元素交换，然后删除最后一个元素，然后从堆顶元素开始从上往下进行堆化，也就是比较交换，直到叶子结点。
**往队中插入数据和删除数据的时间复杂度都是O(logn)**。
**堆化的时间复杂度是O(logn)**。

## 经典的应用就是堆排序
个人总结，堆排序主要是两个操作：**建堆**和**排序**。
这两个操作都用到了类似于删除堆顶元素的从上往下的堆化的方法。

首先，我们要对原数组进行建堆（大顶堆），也就是使其变成一个大顶堆，建堆完了之后我们就开始排序：
- 1.将堆顶元素与最后一个元素交换
- 2.交换后的要排序的数组长度-1
- 3.对交换后的数组进行堆化，使其再次变成一个堆
- 重复123，直到要排序的数组中只有一个元素

## 代码实现
我实现的具体代码：
```
//堆排序的堆化(从上往下)！堆采用数组下标为0开始。有两种堆化，一种是从上往下，一种是从下往上
void heapify(vector<int> &ivec, int n, int i)
{
	
	while (true)
	{
		int maxpos = i;
		if ((2 * i + 1 <= n - 1) && (ivec[2 * i + 1] > ivec[i]))
		{
			maxpos = 2 * i + 1;			
		}
		if ((2 * i + 2 <= n - 1) && (ivec[2 * i + 2] > ivec[maxpos]))
		{
			maxpos = 2 * i + 2;
		}
		if (maxpos == i)
		{
			break;
		}
		else
		{
			int tmp = ivec[maxpos];
			ivec[maxpos] = ivec[i];
			ivec[i] = tmp;//这里之前写成了=ivec[maxpos]，真的是老是犯这种低级错误。
			i = maxpos;
		}


	}
}
//建堆
void buildHeap(vector<int> &ivec, int n)
{
	for (int i = (n - 1) / 2; i >= 0; i--)//从第一个非叶子结点开始堆化
	{
		heapify(ivec, n, i);
	}
}

//堆排序,堆排序主要是两步：建堆和排序。先建堆，然后排序利用删除堆顶元素的方法来排序
void heapSort(vector<int> &ivec, int n)
{
	//建堆
	buildHeap(ivec, n);
	for (auto a : ivec)
	{
		cout << a << " ";
	}
	cout << endl;
	//排序
	int k = n - 1;
	//将堆顶元素与最后一个元素交换
	while (k >= 0)
	{
		int tmp = ivec[0];
		ivec[0] = ivec[k];
		ivec[k] = tmp;
		//从上往下堆化
		--k;
		heapify(ivec, k + 1, 0);
	}
}
```
在实际运行中，10000个在范围为10的随机数的排序时间为828ms左右，范围100000，时间为1797ms左右
{% note success %}
- 堆排序建堆过程的时间复杂度是O(n)
- 排序过程过程中的时间复杂度是O(n\*logn)
{% endnote %}

## 为什么堆排序没有快排快
总结两点：
{% note danger %}
- 快排是顺序访问，而堆排是跳着数据访问，也就是说，因为二叉树在数组当中存储的特性，当数据量特别大的时候，访问当前结点的子结点或者是父结点的时候，就会跨越很大的数据量，根据空间局部性原理来讲，这对于高速缓存很不友好。
- 虽然快排和堆排是不稳定的排序算法，但是堆排在数据处理上做的更狠，也就是说，堆排在建堆的时候很有可能会打乱原来的有序程度。
{% endnote %}









--- 

