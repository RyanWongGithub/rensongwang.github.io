---
title: 怎么打造一个工业级散列表
tags:
  - 数据结构
categories:
  - 数据结构与算法
date: 2019-07-04 16:09:41
photo:
---

{% note default %}
在学习散列表的时候，发现了C++里面vector容器的影子。
在这里记录学习散列表的过程与个人的理解。
{% endnote %}

<!-- more -->

## 前言
学到后面，发现所有的数据在结构都无非是增删查。
学习二分查找的时候，是为了提高查找一个数据的效率。紧接着学习了跳表，跳表的出现是为了实现链表上的“二分查找”。但是进一步扩展开来，还涉及到数据的插入和删除。时间复杂度都为O(logn)，因为插入，删除之前都先要查找数据。
本次主要要讲的散列表还是围绕三个问题：
- 数据的查找
- 数据的插入
- 数据的删除

## 散列表的原理
散列表依赖的是数组这种顺序存储的数据结构，也就是说，依靠数据的随机访问(连续内存空间)，散列表的查找可以做到O(1)的时间复杂度。
我们存数据的时候，可以通过元素的key值转化为数组的下标，存到对应的位置。我们查找元素时，也是通过元素的key值转换为下标，直接利用数组的随机访问找到元素。

## 散列函数
因此，散列表需要一个散列函数，来把元素key值转化为hash(key)值。
理想中的散列函数是这样的：
- 计算出的hash值是非负整数
- key值相等的元素通过hash函数得到相等的hash值
- 不同的key值得到不同的hash值
前两条不难理解。但是在现实中，第三条往往无法真正满足。
也就是说，**我们无法设计出一个能完全让不同key值得到不同hash值的散列函数**。

## 散列冲突
因此，必然会有冲突，也就是说，有可能key值不同的两个元素通过hash函数得到的hash值是相等的。这就是散列冲突。
解决散列冲突的方法一般有两种：
{% note warning %}
- 开放地址法：线性探测，二次探测，双重散列等
- 链表法
{% endnote %}
具体就不多说了。很简单。
这里主要说一下一些要注意的地方
- 线性探测，在进行删除操作时，不能简单的进行元素的删除，因为我们在进行元素的查找时，会不停往下找，知道遇到空位置。如果我们直接删除元素的话，很有可能，会影响在查找某个元素的过程中，中途遇到空位置就停止了，判定没有这个元素，实际上，要找的元素还在后面。所以一个解决办法就是将要删除的位置设置为deleted，查找元素的时候遇到deleted并不终止查找，而是继续往下探测。
- 用链表法实现的链表的插入时间复杂度为O(1)，而查找和删除的时间复杂度与链表的长度k成正比,为O(k)，k=n/m，n是总数据量，m是槽的个数。

## 装载因子
用开放地址法实现的散列表有一个装载因子的概念。很简单，就是填入的数据/表的长度。为什么要注意这个装载因子呢
因为装载因子越大，说明散列表中的数据越多，越接近表的长度。那么散列冲突会越来越明显。

## 装载因子过大怎么办？动态扩容
装载因子过大，散列冲突概率越大，**不仅插入数据的过程要多次
寻址或者拉很长的链，查找的过程也会因此变得很慢**。为了这种情况的发生，对于动态散列表来说，我们可以对散列表进行动态扩容。
具体这个动态扩容是怎么做的呢。
**当装载因子过大时，我们重新申请一个原来二倍的空间，然后将原来散列表中的元素搬移到新的散列表空间**。
是不是似曾相识？对，C++的vector容器的动态增长的实现也是类似的（后面专门写一篇关于vector的）。
但是与vector不一样的地方在于：**散列表动态扩容时的数据搬移并不能简简单单的直接搬移。**
因为散列表中存入数据是要通过hash函数来确定的，也就是说，如果hash函数确定元素的hansh值与散列表的长度n有关的话，那么，搬移前元素所在散列表的下标位置在搬移后就会发生变化。举个例子：
{% note success %}
有这样一个hash函数：hash(key) = key % n。
原来散列表长度为11，里面有个元素为33，在下标为0的位置。
扩容之后，表长度为22，33这个元素的hash值就变成了11，应该在下标为11的位置。
{% endnote %}

## 如何避免低效的扩容
其实，上述的动态扩容，虽然行得通，但是存在一个很大的**问题**（vector中也存在）：
{% note danger %}
每次进行扩容的时候都要进行申请内存空间然后搬移数据（散列表还可能要重新计算hash值）的操作，当数据量越来越大，每次这样一次扩容的操作就会非常耗时，反应出来的现象就好比：你用一台电脑好好的，很流畅，突然卡机死机的感觉。
对于用户来说，某一次他插入数据的时候，特别慢，反应很久。
{% endnote %}

解决方法：
{% note primary %}
当转载因子达到某个阈值的时候，我只进行申请内存空间的操作，并不进行数据的搬移，我**将数据的搬移穿插到数据的插入过程中**。
什么意思呢。也就是说，我先申请一个新的大的空间，不进行数据搬移，每次插入新元素的时候，我不仅仅只把新元素插入到新空间里，同时（可能重新计算hash值）把旧的散列表中的某一个（或某几个）元素也放到新空间中，这样，慢慢的，就完成了数据的搬移工作。**而且在任何时候，都不会有性能突然退化很严重的情况**。
{% endnote %}

总结：
- 动态扩容选好合适的阈值
- 阈值大了容易散列冲突，阈值小了容易浪费内存空间（动态缩容？）

## 散列表碰撞攻击
通过精心设计的数据，可以让数据的hash值都相等，于是，如果基于链表法的散列冲突解决方法的散列表。大部分数据都会集中在一个槽里，查找的效率就会退化成O(n)。

## 工业级散列表举例
Java中的HashMap这样一个工业级的散列表，其他的不多说。
我们重点说一说HashMap的散列冲突解决方法：
HashMap底层使用链表法来解决冲突。但是链表法也避免不了链表过长。
于是引入了红黑树，红黑树的查找效率为O(logn)，也就避免了散列表碰撞攻击。
值得注意的是，当红黑树结点个数小于8的时候又会转换成链表。

## 如何打造一个工业级的散列表
{% note default %}
- 支持快速的查询、插入、删除操作；
- 内存占用合理，不能浪费过多的内存空间；
- 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。
设计思路：
- 设计一个合适的散列函数；
- 定义装载因子阈值，并且设计动态扩容策略；
- 选择合适的散列冲突解决方法。
{% endnote %}

## 散列表和链表放在一起使用
实际上，散列表和链表通常会放在一起使用，redis中的有序集合不仅仅只用到了跳表这一种数据结构，还用到了散列表。

那么散列表和链表如何组合使用呢？
举个例子：LRU缓存淘汰算法
如果单纯用链表来实现LRU淘汰算法的话，那么在缓存中查找、删除、添加一个数据，都会是O(n)的时间复杂度，因为都涉及到查找，在链表中查找是O(n)的时间复杂度。
散列表的查找时间复杂度是O(1)，因此我们在链表法实现的散列表中的拉链上的每一个结点，都多包含前趋指针和后驱指针，这两个指针，并不是用来用在拉链上，而是将散列表的所有拉链纵向连接起来。见下：
<img src="http://rensongwang.gitee.io/my_drawing_bed/散列表和链表的组合使用.JPG">

这样，查找、删除、缓存一个数据要用到的查找操作的时间复杂度被降低到了O(1)。

Java的LikedHashMap用到了类似于LRU缓存淘汰算法。同样也是链表和散列表的组合使用，但是不仅仅局限于上面所说的组合使用方法，比如redis中的有序集合key和score，我们将score组织成跳表，那么通过score来查找很快，但是我们通过key值怎么办呢。于是我们可以再根据key组织一个散列表，通过key找到score。

--- 

