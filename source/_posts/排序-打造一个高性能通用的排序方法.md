---
title: 排序-打造一个高性能通用的排序方法
tags:
  - 算法
categories:
  - 数据结构与算法
date: 2019-07-02 16:50:23
photo:
---

{% note default %}
之前做了关于插入冒泡选择、归并快排、桶排计数排基数排的总结与代码实现。
这篇是关于个人对于上述排序算法的一个总的记录与理解。
然后说一说自己对于打造一个高性能通用的排序算法的理解。
{% endnote %}

<!-- more -->

## 个人实现各种排序算法的实践
冒泡排序：在实际运行中，10000个在范围为10的随机数的排序时间为34812ms左右，范围100000，时间为37157ms左右
插入排序：在实际运行中，10000个在范围为10的随机数的排序时间为12094ms左右，范围100000，时间为13750ms左右
选择排序：在实际运行中，10000个在范围为10的随机数的排序时间为9453ms左右，范围100000，时间为9328ms左右
归并排序：在实际运行中，10000个在范围为10的随机数的排序时间为391ms左右，范围100000，时间为391ms左右
快速排序：在实际运行中，10000个在范围为10的随机数的排序时间为1953ms左右,范围100000，时间为125ms左右
计数排序：在实际运行中，10000个在范围为10的随机数的排序时间为1953ms左右，范围100000，时间为10453msms左右
堆排序：在实际运行中，10000个在范围为10的随机数的排序时间为828ms左右，范围100000，时间为1797ms左右

## 个人通过实践的理解
在之前的博文中也做过一些总结。在这里总的汇总一下。
首先，需要说明的是，这些测试并不是十分严谨，但是能看个大概，还是有一些参考意义。

{% note warning %}
- 三种时间复杂度为O(n^2)的排序算法中，插入算是最好的，一般优选插入，其次，我个人认为，如果不考虑稳定性，选择排序是很好的选择。
- 在归并和快排中，我们选择快排，因为归并有致命的弱点：非原地排序。
- 归并的时间复杂度稳定性很好，从测试数据上可以看出来，排序的效率与数据无关。
- 计数排序，包括桶排和基数排序都是非原地排序，我想这可能是测试数据不理想的原因吧。
{% endnote %}

## 如何打造一个高性能通用的排序方法
在我的了解中，想C++STL里面的sort、C语言的qsort等并非只是仅仅选择一种排序算法。
因为对数据进行排序，并不是仅仅只需要算法牛逼就可以，也要看数据规模，类型等。另外，各种排序算法也有各自不同的应用场景。

但是，我们首选哪个算法来做主体的算法呢？
首先，线性排序算法肯定不行，因为它们的应用场景太特殊，对数据的要求十分苛刻，而且也不是原地排序。
剩下的就是时间复杂度为O(n^2)和O(n\*logn)的排序算法了
如果对小规模数据进行排序，可以选择时间复杂度是O(n^2)的算法；如果对大规模数据进行排序，时间复杂度是O(nlogn)的算法更加高效。所以，为了**兼顾任意规模数据**的排序，一般都会首选时间复杂度是O(nlogn)的排序算法来实现排序函数。
那么O(n\*logn)的排序算法有哪些？
归并、快排、推排序。
我们一般选择快排来作为排序函数的主体排序算法。归并并非是原地排序。

但是我们知道快排不稳定，更为重要的是快排的时间复杂度也不稳定，也就是说，快排的效率跟数据的有序程度有关。

## 如何优化快排
之前在快排的博文中，我写的快排实现代码里面其实实现了一个优化：**三数取中法**。就是在三个数中取中间值来作为分区点。
还有一个方法就是：**随机法**，也就是在数组中随机选取一个数来作为分区点。
另外，快排用递归来实现，如果递归深度很深，会造成堆栈溢出。解决方法：
1. 取一个**阈值**，递归深度超过阈值，停止递归。
2. 手动在堆上模拟一个函数调用栈
总结：
{% note danger %}
- 分区点选取优化：三数取中法、随机法。
- 防止堆栈溢出：阈值法、堆上手动模拟函数调用栈
{% endnote %}

## how

在Glibc中的qsort()事实上用了多种排序算法，源码中，qsort()会优化使用归并排序（各方面很稳定）来处理小数据量（比如1kb、2kb）的排序，虽然会多耗费内存空间，但是在数据量较小的情况下问题不大。当数据量变大（比如100mb）的时候，就会采用快排来处理排序。qsort在快排中选取分区点的方法是**三数取中法**。处理堆栈溢出的问题是采用**堆上手动模拟栈**。事实上，qsort不仅仅用到了归并和快排，还用到了快排，在快排中，当要排序的区间的元素个数小于等于4的时候，会采用插入排序。因为在处理小规模数据时，O(n^2)的时间复杂度不一定比O(n\*logn)高。



--- 

<div align="center">
	**本文作者**：王仁松
	仅供本人记录学习过程与学习交流之用，未经同意，禁止转载！
</div>