---
title: CSAPP：信息的表示和处理
categories:
- CSAPP
date: 2019-03-28 16:18:07
tags:
- 深入理解计算机系统
---
{% note default %}
首先，看了第一章有个大概的认识，再对第二章做一个总结。
这本书确实很牛逼，能够让你对于计算机底层怎么实现的，有个具体的深入的认识和了解。
第一章就跟标题写的一模一样，先带你在计算机的世界里漫游，告诉你具体在哪几章涉及什么知识。
{% endnote %}
<!-- more -->

### 漫游计算机世界
- 信息就是位 + 上下文。大部分现代计算机系统都使用ASCII标准来文本字符。这种方式实际上就是使用一个唯一的单字节大小的整数值来表示每个字符。
- GCC编译系统：1.预处理器 2.编译器 3.汇编器 4.链接器  最后生成可执行文件
- 高速缓存cache至关重要P9
- **进程是操作系统对一个正在运行的 程序的一种抽象。并发运行：一个进程的指令和另一个进程的指令是交错执行的。**
- 虚拟内存还要多理解

##### 数学计算机的整个历史中，两个需求：
1. 做的更多，
2. 运行的更快
所以也就不难理解为什么会有并发和并行。并发呢，是指一个同时具有多个活动的系统。而并行是指用并发来使一个系统更快
- 程序以多线程书写，这些线程可以并行地高效执行-**线程级并发**P18
- **指令级并行：是指同时执行多条指令**
- **计算机系统中抽象地重要性P19**

### 信息的表示和处理
- 这里要十分理解寻址的概念。**在几乎所有的机器上，多字节对象被存储位连续的字节<font color = red>序列</font>，也就是说我的地址的表示的1，那就表示的是一个字节。比如Ox100，表示这个地址是Ox100，Ox101呢是在Ox100基础上加了一个字节，简单地来说，就是地址的基本单位是字节。一个int型的对象，在地址上的跨度就是4**
- **8位表示一个字节，就是2的8次方（二进制），等同于16的2次方（十六进制），所以2个十六进制位表示一个字节**
- **小端表示法**（地位在前，最低有效字节在前）和大端表示法（高位在前，最高有效字节在前）
- C语言中字符串被编码为一个以null（其值为0，Ox00）的字符结尾的字符数组
- 二进制代码是不兼容的
- 移位运算中的**逻辑右移**是指在左端补k个0，而**算术右移呢，是指在左端补上k个最高有效位（最高有效位是0，就补0，是1，就补1）**
- 整数表示：无符号数编码，和有符号数编码，这里以int类型为例讲讲我的理解，首先int类型是4个字节，也就是32位。那么就有2的32次方个不同的表示，也就是说能够表示2的32次方个数。那么，如果是无符号的话，那就是从0开始，表示数的范围就是0~2的32次方-1。如果是有符号的话，怎么办呢。于是我们就把2的32次方分成一半，一半表示负数，一半表示正数。那么最高有效位位0的话，就是正数，从全0开始，就是0~2的16次方-1。最高有效位位1就表示负数，自然也是从小到大排，那么100000……就表示的是最小的那个数（-2的16次方），一直到-1。
**于是我们能够看到位模式的时候，是从0~2到16次方-1，然后是-2的16次方到-1。所以只要超过了2的16次方-1，那么就变成负数了，于是就可能出现两个正数相加结果为负（正溢出）。两个负数相加结果为正（负溢出），这是由于负数在计算机中是最高有效位为1开头的，如果这两个负数都特别小，相加最高有效为因为进位而变成0，后面也没有进位上来，那结果的最高有效位就是0，也就是正数了。**
- **所以有符号数和无符号数之间的转换要十分注意，**（隐式的将有符号数转换为无符号数）。
- 无符号数求反P62
- 实际上编译器为了优化乘法的效率，是通过移位与加减法的结合来实现乘法的P73
- **浮点数牛B，为了表示所有的浮点数，分成了三种情况。P78**
- 舍入P83


---

