---
title: 从C++的构造函数谈vector的深拷贝
tags:
  - vector
categories:
  - 深度探索C++对象模型
date: 2019-08-04 10:24:57
photo:
---

{% note default %}
一直以来，vector容器的对象复制过程我都有些疑惑，在看了C++对象的构造函数和拷贝构造函数的相关理论之后，对于这一块疑惑的地方总算是清楚了一些，我会在此记录C++对象的构造函数到拷贝构造函数，然后对vector做一个总的总结。
{% endnote %}

<!-- more -->
## 原来我之前理解的都错了
1. 如果你的类中没有声明构造函数，编译器会自动生成默认构造函数吗？
答案是不会。
2. 编译器合成的默认构造函数会显式设定类中的每一个数据成员吗？
答案是不会。

对于第一个问题，我自己在本地ide试了一下，确实不会，因为编译过后会直接报错，提示你声明的类对象没有初始化，也就是没有构造函数来初始化。
以前我傻傻认为编译器会自动生成默认的构造函数，事实是不会。
那么什么时候，系统会为你生成默认构造函数呢？
一种方法是
```
 class Test
 {
 	Test() = default;
 	···
 }
```
另外一种情况就是，你这个A类里面有一个其他B类的类对象，也就是类对象成员。
而这个类对象成员的B类定义中显式声明有默认构造函数。
那么这个时候如果你的A类中没有声明构造函数，编译器就会生成一个默认构造函数来对A类中的类对象成员进行初始化，注意，其他数据成员的初始化编译器不管，可是A类中显式声明了默认构造函数，但是，其中并没有对类对象成员进行初始化，这个时候已经有了默认构造函数，编译器该怎么办呢？
在原有默认构造函数上进行扩张，来对类对象成员进行初始化。

**编译器生成默认构造函数只是为了编译器的需求，而不是为了满足程序的需求**。

## 拷贝构造函数
拷贝构造函数一般是这样定义的：
```
class Test
{
	···
	Test(const Test&);
	···
}
```
但是如果自己没有声明，那么这个时候，编译器会根据是否展现了默认拷贝语意来决定（这里我目前没有理解透彻，不讨论）。
所以目前我们认为，没有声明，那么自动会生成一个默认拷贝构造函数。

### 浅拷贝
上述情况下，生成的默认拷贝构造函数是浅拷贝的，什么意思呢？
也就是说，是单纯的复制，并没有资源的重新分配。
通俗来讲，如果你的类中声明有一个指针，**浅拷贝只是复制了指针，就会有两个指针指向同一块内存**！！！
所以说，改变一个对象其中对应的内容，另外一个也会改变。
更严重来说，其中一个释放了对应的内存，另一个释放时，会引发段错误。

### 深拷贝
如果上述情况并不是我们希望看到的，怎么避免呢？
那么就**自己显式的定义拷贝构造函数，并在其中，重新分配资源**。

## vector
vector底层实现就是用的数组，现在一般来说，我们都更倾向于用vector来代替数组。
关于vector的操作，这里就不详细说了。
vector的一个主要的特点就是动态扩容。

## vector的动态扩容
vector的动态扩容是如何实现的呢?
一般而言，概念上来说，vector的动态扩容就是在你申请一块内存空间时，系统会为你搞两倍大的内存空间。
在实际运行中，当你不断插入数据时，某一时刻，即将插入的数据超出了申请的内存空间，这个时候，会在现有基础上，扩大一倍。
注意，只要没有超出，哪怕刚好等于capacity，都不会动态扩容。

## 由基于开放地址法散列表的动态扩容引发的vector动态扩容思考
上述vector的动态扩容存在一个比较严重的问题，那就是如果数据量越来越大的时候，你扩容一次，就会涉及到大量数据的搬移操作，那么就会造成性能的急剧下降甚至崩溃。
如何避免呢？
跟散列表的解决方法一样：
**将数据的搬移操作嵌入于每一次的插入数据操作中**。
通俗的来讲，就是设定一个阈值，当vector中的元素个数超过阈值时，我先申请两倍大的内存空间，并不马上搬移数据。
然后再后面的每次插入数据时，我插到新的内存空间里，然后同时也从旧的vector里面搬移一个元素过来。这样就避免了性能的急剧下降。

## vector的深拷贝
上面提到，vector的扩容是重新申请一块内存空间，然后搬移数据。
不管是搬移，还是插入数据，vector中的对象到底是怎么生成的？
答案是**复制**。
对于基本数据类型的复制，我们直接复制就好了，而对于类对象的复制，是怎么样的呢？

实际上，是根据所存储的类的拷贝构造函数来复制的。
上面说过C++对象的深拷贝和浅拷贝。其实对于vector的对象的复制，个人以为，深拷贝和浅拷贝都是一个道理。
怎么说呢？
个人理解，vector才不管你是深拷贝还是浅拷贝，我只管复制就行了，也就是说：
- 如果你声明的类中显式有默认拷贝构造函数，而且其中有对指针类的成员的资源重新分配，那么我vector的复制就是深拷贝。
- 如果你没有声明拷贝构造函数，那么编译器会为你生成默认拷贝构造函数，但是就没有资源的重新分配，只是简单复制，那么我vector的复制就是浅拷贝。

个人实践，事实如此。













--- 

<div align="center">
	**本文作者**：王仁松
	仅供本人记录学习过程与学习交流之用，未经同意，禁止转载！
</div>