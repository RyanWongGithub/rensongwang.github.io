---
title: 小知识点总结
tags:
  - null
categories:
  - null
date: 2019-04-08 10:37:10
photo:
---

{% note default %}
小知识点
{% endnote %}

<!-- more -->

发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题
红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低
红黑树的高度近似2log2n，所以它是近似平衡，
插入、删除、查找操作的时间复杂度都是O(logn)

跳表：链表+多级索引。实现了“链表的二分查找”

MySQL数据库索引是如何实现的？
我们先来看散列表。散列表的查询性能很好，时间复杂度是O(1)。但是，散列表不能支持按照区间快速查找数据。所以，散列表不能满足我们的需求。
我们再来看平衡二叉查找树。尽管平衡二叉查找树查询的性能也很高，时间复杂度是O(logn)。而且，对树进行中序遍历，我们还可以得到一个从小到大有序的数
据序列，但这仍然不足以支持按照区间快速查找数据。
我们再来看跳表。跳表是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是O(logn)。并且，跳表也支持按照区间快速
地查找数据。我们只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据
就是满足区间值的数据

但是数据库索引是通过一种叫B+树的数据结构实现的。跳表是在链表基础上实现，而B+树是在二叉查找树的基础上实现的。
为了让二叉查找树支持按照区间来查找数据，我们可以对它进行这样的改造：树中的节点并不存储数据本身，而是只是作为索引。除此之外，我们把每个叶子节
点串在一条链表上，链表中的数据是从小到大有序的。
但是索引不可能存储在内存中，因为数据多了，内存根本不够，所以用时间换空间的思想，存储在磁盘上
但是磁盘特别慢，所以为了减少查找索引的次数，我们必须减少树的高度
那么就不能用二叉树了，所以我们用m叉树，m越大，高度越小
B+树的更新操作会比较慢，也很好理解，就像平衡二叉查找树一样，或者就像跳表一样，它添加/删除了数据，还要维护索引。

多道批处理解决了CPU资源充分利用的问题
但是人机不能交互。也就是说我把程序放进去，不能干涉。

所以分时系统：提高计算机系统的交互性
我有时间片了，你的时间片完了，你就得停止等待你的下一个时间片

实时系统：就是要立即响应。在非实时操作系统中，用户要么对操作系统得调度功能没有任何控制，要么就只能简单控制。
但是在实时系统中，允许用户细粒度地控制任务优先级。

动态页式存储管理：
页面淘汰算法：
1. 最佳淘汰算法OPT： 一种理想的淘汰算法，选择将来不再使用或最远的将来才可能被使用的页面进行淘汰。这个是理想的，也就是直接看后面会不会被访问，要看后面，当一个先知来淘汰，
2. 先进先出FIFO： 认为最先调入的页不再被访问的可能性大，所以最先进来的就淘汰掉
3. 最近最少使用淘汰LRU：最近最久没被访问的页，就是选最近最不经常访问的

内存 分区式存储管理
如果是固定分区大小，那么在程序装入之前，就已经将用户空间分好了一个又一个的固定大小的分区。这样就容易形成内碎片（分区内未被使用的无效的存储空间）

所以为了充分利用，有了可变分区大小。容易形成外碎片（分区之间未被使用的无效的存储空间）

分区分配算法：
1. 首次适应算法：该算法要求空闲分区以地址递增的次序链接。在分配内存的时候，从链首开始顺序找，直到找到一个大小满足要求的空闲分区
                          每次查找都是从低地址部分开始
2. 循环首次适应算法：不再是每次都从链首开始查找，而是从上次找的空闲分区的下一个空闲分区开始，直到满足，如果最后一个空闲分区（链尾）
                                 则返回到第一个空闲分区······
3. 最坏适应算法：要求空闲分区链从大到小的顺序形成一个空闲分区链。分配内存的时候，从链首开始
4. 最佳适应算法：最佳就是每次为进程分配内存的时候，总是把能满足的同时又是最小的空闲分区分配给内存。所以要求空闲分区以从小到大的顺序形成一个空闲分区链
5. 快速适应算法：为每一类具有相同容量的空闲分区设立一个空闲分区表，每个链表的表头指针放在索引表中
                          分配内存时，从索引表找到最适合的空闲分区链，从链中取下第一个空闲分区分配
6. 哈希算法：以空闲区大小为关键字的哈希表

进程的三种状态：
1. 运行
2. 就绪
3. 等待

就绪是指进程已经具备了运行的所有条件，就差处理机了
等待是指1. 进程如果在运行状态时需要等待某一事件发生（完成）或者是某一资源被其他进程占用，那么就从运行状态转变为等待状态
等待过程中，如果事件完成，或是得到了某个资源，那么就从等待状态转变为就绪状态，因为这时候系统中可能还有多个进程处于就绪状态，你不能插队吧
所以不可能从等待状态直接变为运行状态！

同步与互斥：
互斥：一组并发进程中的两个或多个程序段，因共享某一公共资源而使得这组并发进程不能同时进入临界区，就叫互斥。
也就是说我在用的时候，你不能用。另外注意。临界区是指进程访问临界资源的那段代码，也就是说临界区——》程序段

同步：在异步环境下的一组并发进程，在某些程序段上需相互合作、互相等待、使得各进程在某些程序段上必须按照一定的顺序执行的制约关系就是同步
也就是说，咱们共同维护一个缓冲区，我往里面放数据，你从里面取，我必须得是有空的才能放，你必须是有数据才能取
前趋关系：咱们共同完成一件大事，你得等我先把我的那部分干完你才能开始干活。

作业调度和进程调度：
由于时间原因，第一部分先不做

死锁的原因：
1. 系统资源不足（根本原因）
2. 进程推进顺序不合适

死锁的必要条件：
1. 互斥条件
2. 不可剥夺条件
3. 部分分配条件：
4. 环路条件（循环等待条件）

数据库特性也好：原子性，一致性，隔离性，持久性

一个派生类继承了所有的基类方法，但下列情况除外：
基类的构造函数、析构函数和拷贝构造函数。
基类的重载运算符。
基类的友元函数。

C++中，动态内存管理是通过一对运算符来实现：new和delete
智能指针呢（share_ptr，允许多个指针指向对象和unique_ptr，独占对象），是为了更好的管理动态对象，与常用指针的区别就在于，它负责自动地释放所指向的对象。
智能指针怎么动态申请内存呢，当然是配合一个标准库函数：make_shared
例子：
``` 
share_ptr<int> p1 = make_shared<int>(42)   申请了一个动态int对象，值为42
```
当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用。
虚函数在底层是怎么实现的？
当一个类或其派生子类中有虚函数时，编译器就会为这个类生成一个虚函数表（类所有的对象共享），保存该类的所有的虚函数地址，另外每一个类对象
还有一个虚表指针（每个对象都有），指向该类的虚表，通过指针或引用调用虚函数时，就会根据具体的指向的对象的虚标指针找到该类对象的虚表，然后调用对应的虚函数

Git：
HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。
穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。
每提交一个新版本，实际上Git就会把它们自动串成一条时间线。
工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。
Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD

分支管理
前面说到版本库，除了暂存区很重要之外，还有分支，就像前面说的，每提交一个新版本，实际上Git就会把它们自动串成一条时间线。master就指向对应的提交点，HEAD指向master
如果这时候master分支上是多个人共同合作，那么问题就来了，这个时候你还没有完成你的工作，提交了不完整的版本库，别人就工作不了，等完成了再提交，团队工作效率低

这个时候，就可以再创建一个分支，我再拉一条时间线出来，然后让HEAD指向当前分支，你在你自己的分支上工作，对工作区的修改和提交都是针对你自己的分支了
当你在你自己的分支上完成工作后，再把分支合并到master上就OK了















--- 

