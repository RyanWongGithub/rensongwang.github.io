---
title: 链接：一个程序到一个进程的蜕变
tags:
  - 进程的开始
categories:
  - 操作系统个人理解系列
date: 2019-08-23 20:28:36
photo:
---

{% note default %}
以前跳过链接直接学习虚拟内存，总是有一些疑惑的地方：一个程序在变成进程的过程中，虚拟内存到底做了哪些工作？
在此只是说个大概，重点在于虚拟内存在一个程序变成进程时做了什么？
{% endnote %}

<!-- more -->

## 一个程序变成可执行文件的主要流程
一个程序要变成一个系统可以执行的可执行文件，主要经过4个阶段。
预处理、编译、汇编、链接。
以上一般来说是，预处理器、编译器、汇编器、链接器，组合成一个**编译器驱动程序**。
第一步源文件通过预处理器被翻译成一个ASCII码的中间文件.i，然后到了编译器被翻译成ASCII码汇编文件.s，然后通过汇编器变成一个**可重定位目标文件.o**。最后是**链接器**，链接器会将不同的.o文件组合在一起，创建一个**可执行文件**。
最后shell调用一个叫**加载器**的东西来执行可执行文件。

## 链接分为静态链接和动态链接，我们先看静态链接
静态链接呢，就是将不同的源文件通过上述一系列操作最后组合在一起变成一个可执行文件，这里静态链接的输入就是一组可重定位目标文件，这里我们简化，实际上可重定位目标文件，就是将源文件里面声明的代码和数据分开，变成一个一个的节（**每一节都是一个连续的字节序列**），我们简化编译器的工作，最后的可重定位目标文件，即是如图：
<img src="https://myblog-1259049552.cos.ap-shanghai.myqcloud.com/%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6.png">

上图就说明了，编译器和汇编器就生成了从**地址0**开始的代码和数据节，注意从0开始（相当于编译器确定了源文件中函数和全局变量的相对位置），实际上，**目标文件就是字节块的集合**。
符号表中就是相当于每一个符号对应一个函数、一个全局变量、一个静态变量（注意，没有局部变量），目标文件主要是生成符号和符号引用，链接器要做的**第一个工作就是将每一个符号引用和符号定义关联起来**。
而图中的.rel.data和.rel.text是干什么的呢？这是因为如果源文件中引用了有来自于其他源文件的变量，编译器没办法知道变量的具体地址（相对地址，因为链接之后放在哪编译器哪知道，那是链接器的工作），所以编译器就把那些来自外部文件的引用的变量啊，函数的相对地址置为0x000000，并生成一条记录，代码的就在.rel.text，数据的就在.rel.data。

## 链接器主要干的事情：重定位（关于进程虚拟地址的一些线索）

---

静态链接主要是将一组这样的文件组合在一起，而每一个可从可重定位文件都是上图中排列，从0开始，**链接器就是要将不同目标文件的代码段、数据段等整合在一个可执行文件中**，这就要涉及到对这些字节块的重新组合，代码段的放一起，数据段的放一起。

举个例子：
我们假设链接器需要链接三个目标文件：

- 目标文件一：该文件数据段定义了两个变量apple和banana，apple的长度为2字节，banana的长度4字节，因此目标文件一的数据段长度为6字节。从图中也可以看出apple的内存地址为0，也就是相对地址，即apple这个变量在目标文件一的地址是0，banana的地址为2。
- 目标文件二：该文件的数据段比较简单，只定义了一个变量orange，其长度为2，因此该目标文件的数据段长度为2。
- 目标文件三：该文件的数据段定义了三个变量grape、mango以及limo，其长度分别为4字节、2字节以及2字节，因此该目标文件的数据段长度为8字节。
<img src="https://myblog-1259049552.cos.ap-shanghai.myqcloud.com/%E4%B8%8D%E5%90%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E4%BD%8D.png">

链接器在链接三个目标文件时其顺序是依次链接的，链接完成后：

- 目标文件一：该数据段的起始地址为0，因此该数据段中的变量的最终地址不变。
- 目标文件二：由于目标文件一的数据段长度为6，因此链接完成后该数据段的起始地址为6(这里的起始地址其实就是偏移offset)，相应的orange的最终内存地址为0+offset即6。
- 目标文件三：由于前两个数据段的长度为8，因此该数据段的起始地址为8(即offset为8)，因此所有该数据段中的变量其地址都要加上该offset，即grape的最终地址为8，即0+offset，mango的最终地址为4+offset即12，limo的最终地址为6+offset即14。
从这个过程中可以看到，数据段中的相对地址是通过这个公式来修正的，即：

  相对地址 + offset(偏移) = 最终内存地址
而每个段的偏移只有在链接完成后才能确定，因此对相对地址的修正只能由链接器来完成，编译器无法完成这项任务。

当所有目标文件的同类型段合并完毕后，数据段和代码段中的相对地址都被链接器修正为最终的内存位置，这样所有的变量以及函数都确定了其各自位置。

完了吗？没有，上面说过，那些.rel.data和.rel.text中的符号的地址都是0，那么现在最终的相对地址都确定了，那我一个一个的改好。
但是，这个地址还只是相对地址，**从0开始的**，这个时候链接器会把**运行时内存地址**赋给每个节，赋给每个节中的每个符号。这一步完成，**程序中的每一条指令和全局变量都有唯一的运行时内存地址了**。
**注意，上面说的运行时内存地址个人认为实际上指的就是虚拟地址！！！**
然后链接器修改每个符号引用，使它们指向对应的运行时地址。

这也是为什么可执行文件很容易被加载进内存的原因，在可执行目标文件的格式中有一个**程序头部表**，里面记录着代码段从哪开始（**Ox400000!!!**），多少个字节，独写访问权限，偏移量（第一个节的偏移量），初始化多少个字节；
数据段从哪开始（**一般在代码段后面，由于字节对齐，实际上与代码段之间有缝隙**），多少个字节，独写访问权限，偏移量（第一个节的偏移量），初始化多少个字节（.bss全部初始化为0，也就不用初始化了）。

## 加载可执行文件
在加载时，会根据执行文件中的程序头部表创建一个**进程的内存映像**。
<img src="https://myblog-1259049552.cos.ap-shanghai.myqcloud.com/%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png">

有没有很熟悉！
这里每个程序都会有一个内存映像，入上图，从虚拟地址0x00000000到0xffffffff。
虽然csapp原文中说，在程序头部表的引导下，将可执行文件的片复制到代码段和数据段。
**我认为，这个复制指的就是广义上将程序加载到内存运行。**
实际上：当shell运行一个程序时，父shell进程生成一个子进程，它是父进程的一个复制。子进程通过execve系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码，数据，堆和栈段。新的栈和堆被初始化为0。通过将虚拟地址中的页**映射**到可执行文件的页大小的片，新的代码段和数据段被初始化为可执行文件的内容。最后加载器跳转到_start地址，它最终会调用应用程序的main函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制。此时操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。

注意上面说的映射，映射来初始化虚拟内存区域的内容，这个后面会有博文要讲，但是目前我也有点摸不清楚这个映射具体是如何操作的。

参考资料：
csapp
<a href="https://segmentfault.com/a/1190000016433947">彻底理解链接器：重定位</a>





--- 

<div align="center">
	**本文作者**：王仁松
	仅供本人记录学习过程与学习交流之用，未经同意，禁止转载！
</div>