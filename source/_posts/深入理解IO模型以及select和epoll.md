---
title: 深入理解IO模型以及select和epoll
tags:
  - IO模型之select和epoll
categories:
  - 操作系统个人理解系列
date: 2019-08-25 11:07:58
photo:
---

{% note default %}
在进行简单的Web服务器的开发过程中，我考虑了多进程、多线程实现并发，最后选择了预线程化的并发，实际上，一般的大型服务器在解决高并发状态下客户服务，都会选择基于IO多路复用模型的并发。在此我了解了一些IO多路复用模型，并做一个总结与思考。
{% endnote %}

<!-- more -->
## 本文建立在以下前提
- IO多路复用模型中对于多个描述符的监视任务是交给内核来处理的，也就是说要将需要监视的描述符的集合传递到内核空间中进行处理，这里我们不讨论其实现细节，全当内核自动完成工作。
- 在内核中可以申请回调函数callback，意思是告诉内核：当某个描述符的事件（中断）到达之后，调用回调函数进行相应工作的处理。

## 为什么会有多种IO模型
个人认为这是因为操作系统设计关于用户空间和内核空间以及用户模式和内核模式的细节所造成的。
当申请某个系统调用时，相当于是去办事大厅申请办事，这个时候内核就要接管具体的业务来进行处理，然后反馈给用户进程。

实际上内核管理着系统中各种各样的进程和线程，这个后面专门有一篇博文介绍。
也就是说CPU可能就一个，那么这种资源对于进程或者是线程来说都是抢占的对象，而内核就做着调度的工作。

那么内核是根据什么来进行调度的呢？
这里主要说一说**进程的阻塞**。
一个进程在执行过程中，如果期待某个事件的发生或是说期待某个业务能够处理完成，那么在一段时间里进程是干不了其他事情的，只能等待，这个时候进程就会选择自我阻塞来让出CPU资源。
所以一般来说，**阻塞是进程自身的行为。**

### 缓存IO
当用户申请进行数据IO时，**数据会先拷贝到内核空间的缓存区，然后再从内核空间的缓冲区将数据拷贝到用户空间**。
所以，**数据频繁的在内核空间与用户空间之间进行拷贝会造成很大的内存和CUP开销。**

### IO过程
进程进行一次IO（以read为例），数据会先被拷贝到内核空间的缓冲区，再从内核的缓冲区拷贝到用户空间。
所以进行一次read调用，会经历两个阶段：
{% note warning %}
1. 等待数据准备好（等待数据拷贝到内核）
2. 将数据从内核拷贝到用户空间
{% endnote %}

那么一般来说，个人认为，如果一个应用需要高效率的执行，那么就需要一些不同IO模式来进行服务。
因此就有了下面的IO模型：
- 阻塞IO
- 非阻塞IO
- IO多路复用
- 信号驱动IO
- 异步IO

### 阻塞IO
阻塞IO就是上面说的那种情况，进程调用read之后为了等待read完成，会一直阻塞。
特点就是在两个阶段都被阻塞了。

### 非阻塞IO
非阻塞IO就是说，当我申请read的时候，如果内核这个时候发现数据没有准备好，那么调用read时，不会阻塞而是马上返回一个error，不会阻塞在数据准备阶段，那么从用户角度来看，我调用read之后如果数据还没准备好，会立马返回，那么就提供给我可以在此调用read的权力，这个时候就可以一直不断的调用read来骚扰内核，知道某一刻调用时，数据准备好了，就会成功然后开始拷贝。
所以非阻塞IO的特点是，在第一阶段可以不用被阻塞，然后允许用户不断轮询内核数据准备好了没有。这里还是比较重要的，因为一般来说，IO多路复用的socket都设置成非阻塞IO。

### IO多路复用
IO多路复用是指，单个进程可以同时处理多个描述符的IO，我们常见的就是select和epoll等模型。
原理就是如果某一个描述符通过select或者是epoll来进行IO的操作（这里用select举例），进程会阻塞在select而不是系统调用read上，select会不断轮询负责所有的描述符，当某个描述符可以读（数据到达了）了，就会通知进程。
**这就是为什么一般来说把socket设置成非阻塞的了。
个人认为，是因为select要不断轮询负责的所有描述符，轮询的方式还是通过内核来实现的，不然一问内核就阻塞在那，那select还工不工作了？**

### 异步IO
我喜欢把异步的方式成为“霸道总裁”的方式，进程跟劳工内核说：我要个数据，准备好了放我办公室桌子上。然后转身就走。
也就是进程如果采用的是异步IO，在调用read之后就干其他事去了，也不管数据了，反正内核会完成工作的。

## 总结一下

---

非阻塞和阻塞的区别：
阻塞就是一旦申请就会阻塞（死脑筋），而非阻塞就是去申请了然后选择干其他事，管你是干啥还是不断骚扰工作人员（厚脸皮），这就给了具体进程的更多的操作可能性（而select就需要这样的可能性）。

异步与同步的区别：
**个人认为同步就是一个执行流程下来，进程会因为等待某些事件（IO）发生而限制执行状态，**相当于是一条时间线**。
而异步呢，不会因为时间和空间的问题而受限制，也就是说采用异步的进程的时间线是会在某个事件的时间点而衍生出更多的时间线，而主时间线也就不受各种限制。
就拿上面的例子来说，同步IO不管是阻塞的还是非阻塞的，最后都会在具体的IO操作上（也就是将数据拷贝到用户空间）阻塞，而异步IO在申请read之后衍生出一条read的时间线，主时间线是不受影响的。**

## select的工作原理

---

在这里就不介绍具体的函数了，主要说说工作原理，select通过将一个特定的描述符集合传递给内核来完成对与描述符集合中的每一个描述符的监视，这个集合的设计也比较巧妙，是通过位来实现的：
**准备集合**：
```
描述符：  3  2  1  0
	位：  1  0  1  0
```
如上，一个集合里面如果要监视描述符3和描述符1，就是上面的状态。然后剩下的工作就是不断的轮询， 直到有描述符的数据到达或者是某个事件可行。就会把相应的位设为1，注意，这个意思就是要改变内核中具体的集合。
举个例子，加入描述3的数据到达了，1还没有，内核轮询一遍之后会把集合改为如下：
**准备好集合**：
```
描述符：  3  2  1  0
	位：  1  0  0  0
```
然后再把这个准备好集合拷贝给用户进程，用户进程再对相应的描述符进行处理。

## epoll的工作原理
epoll创建一个句柄，这个句柄也是一个具体的文件描述符，所以epoll就是一个文件描述符来监视多个文件描述符。
接着，进程通过**内存映射**将内核空间的一块虚拟地址空间和用户空间的一块虚拟地址空间映射到同一块物理内存地址，这样内核对这一块区域做的改变用户进程也能看到。
减少了epoll监听的句柄从用户态拷贝到内核态，内核可以直接看到epoll监听的句柄，效率高。

在这样一块内存中建立一个**红黑树**，而红黑树存储的就是要监视的描述符，同时还建立了一个**就绪链表**。
在将具体描述符加入句柄时，会将描述符插入到红黑树，然后还会像内核注册一个**回调函数**，用来通知内核：一旦这个描述符的中断到达，调用回调函数并将这个描述符插入到就绪链表中。
当调用epoll_wait返回时，返回的就是这个就绪链表，然后用户进程就可以将这个就绪链表拷贝到用户空间指定的集合中进行处理。
注意：上述只有一次数据拷贝操作。

# select和epoll的总结对比

---

为什么一般用epoll而不用select呢？我个人认为以下几点：
{% note success %}
- select用于监视的句柄需要反复的在内核空间和用户空间之间拷贝，而且每次select之前都要跟新准备集合。而epoll通过**内存映射**，这个阶段不需要任何的数据拷贝，句柄的维护成本也相对较低。
- select监视描述符的方式是通过不断的轮询，需要遍历整个集合，而epoll则是通过回调函数方式，另外select返回的也是整个准备好集合，用户进程要处理相应的描述符，还是需要遍历整个集合。而epoll则是返回一个就绪链表，对于那些还没有准备好的描述符是不返回的，这样用户进程的处理效率就会提高。
- select能够监视的描述符的数量最多为1024，而epoll没有限制
- epoll有LT和ET两种模式，而select只有LT一种。
{% endnote %}

## epoll的ET模式和LT模式
一般来说，epoll是默认LT模式，当epoll_wait返回时，用户进程可以将就绪链表拷贝到指定集合空间中，然后清空就绪链表，另外还会做一件事，就是检查这些句柄是不是LT模式，如果是，只要该句柄（这里指的是具体的描述符）上还有事件，就会再次将该描述符插入到就绪链表中，下次返回时还会继续通知，而ET模式，只有在0->1的中断到达时才会通知，其余一律丢弃。

举个例子，如果某个描述符上数据没有读完，下次再调用epoll_wait时，还会返回，继续读未完的。
而ET呢，直接丢弃未读完的数据。
所以ET一般是高效率高性能的并发时候才用到，个人猜测，像直播这种行业会采用这种吧。








--- 

