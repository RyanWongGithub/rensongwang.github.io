---
title: 内存映射：虚拟内存进行工作的进一步真相
tags:
  - 内存映射
categories:
  - 操作系统个人理解系列
date: 2019-08-24 09:24:18
photo:
---

{% note default %}
长久以来，我一直被虚拟内存的真实存在以及如何为一个进程工作所困扰，在了解了程序的链接之后，发现了一些蛛丝马迹，从此慢慢打开了我的疑惑，但是仍然有一些细节没有解开，值得思考。
{% endnote %}

<!-- more -->
## 以下个人理解建立在如下前提
- 虚拟内存区域内容的初始化是通过与磁盘上某个文件对象**关联**实现的，这个关联值的就是内存映射。
但是映射的具体操作是什么呢？含义是什么呢？目前我还尚不得知，但是说到映射，我们从字面意思应该可以理解，就是两个对象之间是相互联系的，本文不讨论映射的细节，全当它在自动工作，因此假设，虚拟内存区域的内容就是对象上的内容（这个假设并不是十分确切，因为对私有对象的写并不会反应到磁盘上真实的对象上）。
- 虚拟内存就相当于是讲内存看作是一个存储在磁盘上的地址空间的高速缓存。

## 两个问题
1. 如何通过读写内存位置读或修改一个磁盘文件的内容？
2. 如何加载一个文件的内存到内存中，而不需要显式的从磁盘到内存的复制？

对于问题1，我的理解：
既然把内存看作是对于磁盘的一个高速缓存，那么在高速缓存的工作原理中，对于高速缓存中的写也能反映到内存中；
**那么我们的内存存的实际上是磁盘上的内存，改变内存上的内容也能反映到磁盘上的真实对象**。

那么问题来了，可执行文件中不是有代码段和数据段吗，数据段中全局变量或者是静态变量被映射到虚拟内存区域，然后内存又是缓存的对应区域的东西，那如果进程在运行中改变了这些变量的值，是不是也会反映到磁盘上真实的对应的可执行文件中呢？

虚拟内存很聪明：
一个对象可以被映射到虚拟内存的一个区域。
主要分为两种对象：共享对象，私有对象。
{% note success %}
- 如果一个进程将一个共享对象射到到它的虚拟内存的一个区域，那么这个进程对这个区域（也就是这个对象在内存上的位置上的内容）做的任何修改，对于那些也把这个共享对象映射到它们虚拟内存的其他进程也是可见的，并且，这些变化也会反映到磁盘上的原始对象中。
- 对于一个映射到私有对象的区域所作的改变，对于其他进程是不可见的，同时也不会反映到磁盘上的原始对象中。
{% endnote %}

很明显，数据段属于一个进程的私有的虚拟内存区域，简称私有区域。同样的，也有共享区域。
具体是怎么工作的，这要依赖于MMU内存控制单元和页表的工作，它们要完成虚拟内存的地址到真实物理内存的地址的**映射**。
注意，这里又是映射，每一个进程的**内存映像**的基本格式都是一样的，也就是说哦，不同进程的虚拟地址空间的基本格式是一样的，两个不同进程的两个虚拟地址可能是相同的，但是映射到物理内存上就是不一样的地址。
那么私有对象就是映射到不同的物理地址，对于其他进程来说就是透明的。
共享对象就是映射到相同的物理地址，对于其他进程是可见的。

这一切都是MMU和页表也就是虚拟内存系统在背后自动工作，我认为这也是虚拟内存强大的一个地方。具体细节我在《虚拟内存有多强大》的博文中有介绍。

另外私有对象用一种叫**写时复制**的技术被映射到虚拟内存。
两个对象将一个私有对象映射到它们不同的虚拟内存区域，但是**共享在物理内存的同一副本**，对于这样的每个进程，它们的页表相应的私有区域的页表条目被标记为**只读**，并且区域结构标记为**私有的写时复制**。
当一个进程试图写这个私有区域的内容，**某个页面**的时候，这个写操作会触发一个保护故障。
然后故障处理程序会发现是写时复制，那么会在物理内存中创建一个**这个页面的新副本**，更新页表条目指向这个新的副本，恢复对这个区域的写权限。当故障处理程序返回时，就可以写了。

没错，父进程与子进程就是这样的，因为创建一个进程会耗费很大的资源。
我认为，写时复制主要是两个优点：
- 充分利用了虚拟内存机制，极大的节省了内存空间。
- 保持了每个进程虚拟内存的独立内存空间的概念。

当然共享对象的一个好处并不仅仅是通过读写内存位置来修改一个文件的内容。
**进程间通信用到的也是共享内存**。
**动态链接用到也是这个共享区域的概念**。

问题2 也就是加载时，只是完成了虚拟内存区域与磁盘上对象的映射，并不进行显式的从磁盘到内存的复制过程，当CPU或者时某条指令引用对应的内存位置上内容时，才会按需调度页面进内存。

## 虚拟内存提供的用户级内存映射
mmap可以使我们自己创建一些虚拟内存区域，并与磁盘上某个对象进行映射。
```
#include <unistd.h>
#include <sys/mman.h>

void *mmap(void *start, size_t length, int port, int flags, int fd, off_t offset);

返回：成功则为指向映射区域的指针，若出错则为MAP_FAILED(-1)。
```
mmap要求内核创建一个新的虚拟内存区域，最好是从地址start开始的一个区域（一般来说，把start取为0或者是NULL，来告诉内核自动工作)，并讲文件描述符fd指定的对象的一个连续的片**映射到**这个新的区域。连续的片的大小是length，这里一般取为文件大小，从文件开始处偏移量offset开始映射。这个offset一般取为0，从文件头开始。
参数port是指新映射的虚拟内存区域的访问权限位。如下：
- PROT_EXEC:这个区域内的页面由可以被CPU执行的指令组成。
- PROT_READ:这个区域内的页面可以读。
- PROT_WRITE:这个区域内的页面可以写。
- PROT_NONE:这个区域内的页面不能被访问。

参数flags描述被映射对象的类型（私有的还是共享的）：
- MAP_ANON:被映射的对象是一个匿名对象，相应的虚拟页面是请求二进制0的。
- MAP_PRIVATE:被映射的对象是私有对象。
- MAP_SHARED:被映射的对象是共享对象。

```
#include <unistd.h>
#incldue <sys/mman.h>

int munmap(void *start, size_t length);

返回：成功则为0，出错则为-1。
```








--- 

