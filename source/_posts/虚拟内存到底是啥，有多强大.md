---
title: 虚拟内存到底是啥，有多强大

tags:
  - CSAPP
categories:
  - 操作系统个人理解系列
date: 2019-05-07 13:59:54
photo:
---

{% note default %}
在学习了与计算机系统中虚拟内存相关的知识后，总感觉对于这一部分知识还是悬在空中，没有脚踏实地的感觉，于是查阅了一些资料，也有去看别人的博客和帖子，发现根本不能解决我的疑惑，基本上都是我自己看过且理解的东西，始终都找不到我想要的那部分答案。
有一些甚至是让我非常疑惑，例如：加载可执行文件进内存的时候，并不全部加载进内存，要用的加载进去，暂时不用的剩下的放在磁盘上，当需要时加载进内存，以便可以运行更多的进程。于是说这就是虚拟内存。
这说得没有错，但是能说它就是虚拟内存吗，没有了解过的人一看，哇，原来这就是虚拟内存啊：把磁盘当成内存来使，虚拟一个内存出来就是虚拟内存啦。
其实上面所说的是swap交换区，正文会讲。
我看过一些资料，也问过一些了解的人。有人的一个解释就是：上面的也叫虚拟内存。
而我认为，我所要讲的虚拟地址空间也是虚拟内存。在正文中我会对这两个虚拟内存做一个解释。
当然我并没有觉得谁对谁错，因为我总是保持一个怀疑的态度。
毕竟我也不能说我说的就是对的，每个人理解不一样。
在这里我个人角度来说明一下什么是虚拟内存，有什么用，并记录我的学习过程。
{% endnote %}

<!-- more -->

## 先不要虚拟内存
在我们想搞明白虚拟内存是啥之间，首先我们要想一下，没有虚拟内存是个啥样子。
我们应该知道，要运行一个程序，必须先得加载进内存，那么就应该知道：
物理内存：从0开始到M的字节序列。
没有虚拟内存，那就要物理寻址。

那这个程序加载内存的哪个地方呢？
操作系统干这事，不用管它把程序放在内存哪个地方，我们只需要知道在内存哪个地方就OK，放好了之后，那每个进程都有对应的物理地址。
那问题来了：
1. **用物理寻址好不好管理呢？**
比如说你进程A是0到巴拉巴拉，其他进程又是不一样的物理地址，人一多了，创建的时候，我还要专门给每个进程这里设计好，那里设计好，所有细节都要安排好。
安排麻烦不说，你每个进程对应的哪块地方的地址还不一样···
我现在就想要一个模板，创建进程的时候，所有的都按照模板来，代码放哪，数据放哪，都是一样的地址，我好管理。但是物理地址就一个啊，地方就一个啊，怎么办？

2. **进程在物理内存中感觉不到安全感**
既然是物理寻址，通过物理地址就能访问修改对应的数据，有一个进程A待在内存里好好的，突然A的一部分被修改了，因为A和其他进程共享一整块物理内存啊，我在你隔壁，没事我就骚扰你，
因为我看得到你呀，我能通过物理地址去访问修改属于你的东西。
这样的话，A不仅觉得物理内存不是他一个人在使用，而且没有安全感，随时都可能被骚扰。

## 虚拟内存来解决问题
上面两个问题说明了如果单纯用物理寻址（物理内存来管理），根本解决不了（当然还有很多的问题，这里说两个主要的）。

现在我想解决问题，怎么办呢，我想所有的进程都是一样的一个地址空间，而且要让他感觉只有他一个人在用一整块物理内存。
那么，我就告诉每个进程：你的地址空间是0到N字节序列，这就是物理内存，只有你一个人在用哦。
是不是觉得有点骗人的感觉，没错，操作系统就是骗了每个进程。
但是解决了很多问题：
{% note success %}
1. 每个进程的虚拟地址空间都是一样的，就相当于每一个进程用的都是虚拟的一整块内存。每个进程存的格式就可以规定下来。也就是说模板的问题解决了
2. 由于我给你的是虚拟内存，你要访问物理内存还要从虚拟内存映射到物理内存，那么你的虚拟内存没有分配的地方你访问不了，你只能访问你的虚拟内存已经映射的物理内存，这块物理内存是你的，没得你没法访问，也就没办法修改，这就保证了每一个进程的地址空间都是独立的，不会被其他的进程所更改。
{% endnote %}

## Linux虚拟内存系统
通过上面的描述，我们应该有了一个较为清晰的认识，虚拟内存的强大就在于，它方便管理而且为每个进程都提供了一个独立的地址空间，当然还有很多好处。
它自动工作，而不需要我们过多的去担心。
在Linux中，一个进程的虚拟内存是这样的：
<img src="http://rensongwang.gitee.io/my_drawing_bed/一个Linux进程的虚拟内存.png">
<img src="http://rensongwang.gitee.io/my_drawing_bed/进程地址空间.png">
每个进程都是这样的，这就是我之前提到过的模板。
在这里，我们关心的是，Linux将虚拟内存组织成一个一个的区域（也叫段），一个区域就是已经存在着的（已分配）虚拟内存的连续片（chunk）。
已分配是指，在磁盘上已经分配了虚拟页，就是已经有数据和它们关联。
已分配分为两种情况：
- 缓存的：当前已缓存在物理内存中的已分配页
- 为缓存的：已分配，但是未缓存在物理内存中

未分配也就是没有创建的页，没有任何数据和它们关联，也就不占用任何磁盘空间。

### 为什么要弄成区域呢？
因为这样，虚拟地址空间就是有空隙的，那些不属于某个区域的虚拟页是不存在的，就不能被进程引用。
同时内核也不用记录不存在的虚拟页，也就不占用内存、磁盘或者内核本身中的任何资源。

### 那具体的区域在进程中又是如何组织的呢？
<img src="http://rensongwang.gitee.io/my_drawing_bed/Linux是如何组织虚拟内存的.png">

1. 内核为系统中的每个进程都维护一个单独的任务结构（源代码中的task_struct）。任务结构中的元素包含或指向内核运行该进程所需要的所有信息。
2. task_struct的mm指针，指向了mm_struct，该结构描述虚拟内存的运行状态。
3. mm_struct的pgd指针指向进程的一级页表的基地址。mmap指针，指向vm_area_struct链表。
4. vm_area_struct描述area的结构，也就是一个具体区域。包含下面的字段：
- vm_start：表示area的开始位置
- vm_end：表示area的结束位置
- vm_prot：表示area内的页的读写权限
- vm_flags：表示area内的页面是进程私有还是共享
- vm_next：指向下一个area节点

# 有一点懂了，虚拟内存在底层到底是怎么工作的，虽然这不需要程序员去操心，个人执着
个人理解，并不是权威，在这里可以保持怀疑。
首先我们先了解一下
## 内存映射
内存映射就是将虚拟内存的一块区域与磁盘上的某个对象关联起来，以初始化这个虚拟内存区域的内容。
虚拟内存区域可以映射到两种类型对象：
1. Linux系统中的普通文件
2. 匿名文件，全是二进制零

前面已经理清了虚拟内存怎么组织，那么一个程序进入内存，变成进程，虚拟内存怎么在底层呈现的呢？
个人理解（不一定正确），一个程序要运行，肯定要加载进内存，这个时候虚拟内存怎么工作的呢：
{% note default %}
1. 创建一个新进程
2. 将可执行文件（目标文件）的.data和.text节加载到新进程中
3. Linux加载器为代码和数据段分配虚拟页，并把它们标记为未缓存的，因为**按需调度**
- 这个时候，就会具体用在磁盘上可执行文件这个对象的代码部分，数据部分与虚拟内存区域关联起来，以初始化代码区，数据区，其他区域类似。
4. 将页表条目指向目标文件中适当的位置
{% endnote %}

有一点，对最后的说明有帮助：<font color="red">**一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的<font color="green">交换文件</font>之间换来换去**
交换文件也叫做交换空间或者交换区域</font>
在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数

有了上述的理解，我感觉整个体系在我这里才算是有一点完整了。

讲到页表，那页表其实也是特别重要的东西

## 页表
有了虚拟内存还不够呀，得有虚拟内存到物理内存的映射。
页表起到关键作用：
每个进程都有一个自己的页表，内容很简单，就是页表条目：PTE
包含的是啥呢，简单来说一个有效位，然后就是一个地址字段（物理地址）
当然，如果
未分配，地址字段对应就是null
已缓存：物理地址
未缓存：磁盘上的地址

地址翻译整个过程：

{% note danger %}
1. 处理器产生一个虚拟地址，发送给MMU（内存管理单元）
2. MMU生成PTE地址，并从高速缓存/主存中请求得到它，因为**页表放在内存中**
3. 高速缓存/主存向MMU返回PTE
4. MMU就会根据PTE的地址字段构造物理地址，再把这个物理地址发送给高速缓存/主存（当然这是页命中的情况下，也就是说**已缓存**的情况）
5. 高速缓存/主存返回所请求的数据字给处理器
{% endnote %}


其中，如果不是简化页表的话，那么正常情况下，在页表上就可以做到访问控制。
也就是在PTE上多添加几个位来控制进程访问某些区域（做到访问控制）
- SUP:超级用户才能访问（内核态）
- READ：可读
- WRITE：可写

## 其实到这，整个体系算是有点摸得清楚了
还有重要的东西是啥呢
前面的Linux一个进程的虚拟内存图中
栈：向下生长的，来实现函数调用，局部变量，参数传递啊啥的，在执行期间可以动态的扩展和收缩
**堆**：向上增长，运行时可以动态的扩展和收缩
堆呢，是动态内存分配很重要的区域，可以在执行过程中动态的分配内存，释放内存
但是很危险，因为操作不当，堆内存没有及时释放，就很容易造成**内存泄漏**的问题

所有一般还有一个很重要的东西就是垃圾回收。这个暂时了解得不多，后期更新。

# 最后，个人查阅资料，来对开篇引言作一个个人理解，解释
引言中提到的swap交换区其实也叫做虚拟内存
但是我们需要明白的是，此虚拟内存非彼虚拟内存
上面**内存映射**提到过，<font color="red">**一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的<font color="green">交换文件</font>之间换来换去**
交换文件也叫做交换空间或者交换区域</font>
个人理解，也就是说，swap交换区也就是上面提到的这个东西，从字面意思上来讲，可以被称为虚拟内存，因为它确实是起到了对物理内存“扩展”的一个支持作用，就如引言所说。
但是，我认为，这个也只是一种形式，并不算是真正意义上的虚拟内存。**我更愿意将我开头所讲的作为真正意义上的从计算机系统角度来讲的虚拟内存**
这两个不是一个东西，所以在讨论的时候必须要说清楚！！！

所以很坑啊，我查阅资料的时候，有些文章就说swap交换区是虚拟内存，有些又是我说的这一套。搞得我懵懵的
同时，百度百科将虚拟内存这个问题处理得很混乱，啥都有。所以一定要辨别！
维基百科的解释我觉得倒是不错：
{% note warning %}
注意：虚拟内存不只是“用磁盘空间来扩展物理内存”的意思——这只是扩充内存级别以使其包含硬盘驱动器而已。把内存扩展到磁盘只是使用虚拟内存技术的一个结果，它的作用也可以通过覆盖或者把处于不活动状态的程序以及它们的数据全部交换到磁盘上等方式来实现。对虚拟内存的定义是基于对地址空间的重定义的，即把地址空间定义为“连续的虚拟内存地址”，以借此“欺骗”程序，使它们以为自己正在使用一大块的“连续”地址。
{% endnote %}

讲到这里，一些困扰我很久的问题算是有点解决明白了
当然还有一些很有意思的东西没讲，比如共享区域、私有对象**写时复制**，后期更新吧



--- 

