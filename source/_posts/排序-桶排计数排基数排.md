---
title: 排序-桶排计数排基数排
tags:
  - 算法
categories:
  - 数据结构与算法
date: 2019-07-02 09:00:07
photo:
---

{% note default %}
三种不基于比较的线性排序。时间复杂度为O(n)。
这里记录一下算法原理和个人理解与总结。
{% endnote %}

<!-- more -->


## 桶排
桶排的核心思想是什么呢？
是桶。这个桶不是一般的桶。
首先，说一说桶排的苛刻要求：

{% note warning %}
- 要排序的大量数据必须要很容易划分成桶，并且桶与桶之间要有**天然的顺序关系**（这点很重要）
- 数据在桶与桶之间的数量要均匀，不能一个桶特别多，一个桶特别少（这种情况会退化成O(n\*logn）。
{% endnote %}

如果满足上述要求，就很好理解了，因为桶与桶之间有顺序关系，我只需要把每个桶里面的数据排好序，再依次取出，所有的数据就排好序了。

接着我们来分析一下时间复杂度，这里我先说一下我的理解，我怎么去分析桶排的时间复杂度呢。
有没有觉得桶排与之前我的关于归并排序的博文里讲的有点类似。

同样是把大量数据划分成小数据，再对小数据进行排序。只不过归并需要再合并。而桶不需要。
因为桶与桶之间有天然的顺序关系。那么当我的桶划分的很多，数据量被划分的很小，我再进行排序，基本上就是常量级的排序了。所以就是O(n)的时间复杂度。

下面说说比较严谨一点的分析。
要排序的数据有n个，我们把它们均匀分到m个桶，那么每个桶里面就有k=n/m个数据，我对每个桶里的数据进行快排，那么时间复杂度就是O(m\*k\*logk),就等于O(n\*log(n/m)),当我们的桶划分很多，接近于n的时候，那么时间复杂度就近似于O(n)。

**桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。**

## 计数排序
计数计数，其实指的就是数据相等的情况下记录个数，我个人觉得，计数排序是桶排的一种极端情况（**大小粒度不一样**），也就是桶划分的**最细**，这样桶里面的就是相等的元素。

计数排序说个例子，100万考生的成绩要排名，怎么去排呢。根据成绩来排序。
这个时候，因为成绩是确定的，而且是0到750分。那么我们划分751个桶，把这些学生分别放到这些桶里，再依次取出，就是有序的排名了。

{% note warning %}
- 要排序的大量数据范围必须不是很大，很大的话可能就变成桶排了
- 计数排序只能给非负整数排序。
{% endnote %}

下面简单来实现一下计数排序。
```
//计数排序
void countingSort(vector<int> &ivec, int n)//计数排序，数据范围不大
{
	int min = ivec[0];
	int max = ivec[0];
	//先遍历数组，找出最大最小值，确定数据范围
	for (int i = 1; i < n; i++)
	{
		if (ivec[i] < min)
		{
			min = ivec[i];
		}
		if (ivec[i] > max)
		{
			max = ivec[i];
		}
	}
	//根据数据范围,确定桶的多少（计数桶）
	int size = max + 1;
	cout << "桶的大小：" << size << endl;
	vector<int> vec;
	for (int i = 0; i < size; i++)
	{
		vec.push_back(0);//这里初始化为0很重要，因为有些桶里就没有数据，顺序累加的时候只能是0！
	}
	//遍历数组，依次存入桶中,是计数...这里出了重大问题！！！
	for (int i = 0; i < n; i++)
	{
		/*
		**这里会发生越界，因为桶的多少与数据范围不一致，比如5个数，全是5和4，桶多少算出来是2！！！
		**我的一个解决办法就是不再用最大最小值来确定桶多少，而是直接用最大值来确定
		**这样做的一个缺点就是可能会造成内存空间的浪费
		*/
		vec[ivec[i]]++;
	}
	cout << "计数后：" << endl;
	for (auto a : vec)
	{
		cout << a << " ";
	}
	cout << endl;
	//将桶数组变成顺序累加数组(这一步开始处理的方法很重要，很巧妙)
	for (int i = 1; i < size; i++)//这里之前写成n了！也很有可能造成越界，和以及不能全部完成顺序累加的问题
	{
		vec[i] += vec[i - 1];
	}
	cout << "累加后: " << endl;
	for (auto a: vec)
	{
		cout  << a << " ";
	}
	cout << endl;
	//再初始化一个大小为n的数组，用来临时存放排好序的元素
	vector<int> vectmp;
	for (int i = 0; i < n; i++)
	{
		vectmp.push_back(0);
	}
	cout << "临时数组" << endl;
	for (auto a : vectmp)
	{
		cout << a << " ";
	}
	cout << endl;
	//遍历一遍ivec要排序的数组，根据遇到的元素值从累加桶里面取出值A，这个A-1(下标)就是最终排序好的位置！
	for (int i = n - 1; i >= 0; i--)//
	{
		int s = vec[ivec[i]];
		vectmp[s - 1] = ivec[i];
		vec[ivec[i]]--;//存了一个元素，对应的累加桶里的值-1
	}
	cout << "排好序的临时数组：" << endl;
	for (auto a : vectmp)
	{
		cout << a << " ";
	}
	cout << endl;
	//最后把临时数组里排好序的数据拷贝到ivec里面
	for (int i = 0; i < n; i++)
	{
		ivec[i] = vectmp[i];
	}
	cout << "排好序的ivec数组:" << endl;
	for (auto a : ivec)
	{
		cout << a << " ";
	}
	cout << endl;
}
```
在这里说一下写代码时遇到的问题BUG以及解决方法
{% note warning %}
- 根据数据范围来确定桶的多少的时候，我最开始的做法是求出最大最小值来确定，这样做会发生越界的问题，比如5个数，全是5和4，桶多少算出来是2。解决方法就是只根据最大值来确定桶范围，也就是[0~max]。但是我想了一下，这样有可能会造成内存空间的浪费，因为数据可能分布不均。
- 在上面顺序累加桶数组的for循环里面写成了小于n，有可能造成越界，和以及不能全部完成顺序累加的问题。

{% endnote %}

在找BUG的时候的测试和找到BUG的测试以及最后成功的测试如下：
<img src="https://myblog-1259049552.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8FBUG.JPG">

下面说一说解决上面所说的确定桶范围造成内存空间浪费的一个个人思路：
其实用最大值和最小值来确定是可行的，只不过要处理好，不然很容易越界。
因此，在遍历数组存入桶中的时候，应该多一步与桶的下标对应的计算(**遍历数组得到的值-min就是桶的下标**)：
```
	···
	···
	int size = max - min + 1;
	cout << "桶的大小：" << size << endl;
	vector<int> vec;
	for (int i = 0; i < size; i++)
	{
		vec.push_back(0);//这里初始化为0很重要，因为有些桶里就没有数据，顺序累加的时候只能是0！
	}
	//遍历数组，依次存入桶中,是计数...这里出了重大问题！！！
	for (int i = 0; i < n; i++)
	{
		/*
		**这里会发生越界，因为桶的多少与数据范围不一致，比如5个数，全是5和4，桶大小算出来是2！！！
		**我的一个解决办法就是不再用最大最小值来确定桶多少，而是直接用最大值来确定
		**这样做的一个缺点就是可能会造成内存空间的浪费
		*/
		vec[ivec[i] - min]++;//这里是改进后的，遍历数组得到的值-min就是桶的下标
	}
	···
	···
```
但是，上述改进在数据范围为100000出现越界问题，其他都能运行，还是有BUG。尚不采用。

在实际运行中，10000个在范围为10的随机数的排序时间为1953ms左右，范围100000，时间为10453msms左右

## 基数排序
我个人对于基数排序的理解就是，基数排序必须需要稳定的排序算法，算是对排序算法稳定性最有力的解释。
应用场景：排手机号。也就是说桶排和计数排序都无法完成，因为数据量太大。
这个时候，如果我们这么思考，那么问题就会简化很多。
我根据手机号的每一位来排序，也就是说我排11次。如果用的是稳定的算法，那么后面的排序不会影响之前的排序。
最后排下来就是有序的。

时间复杂度：每一位我可以用桶排或者计数排。k次就是O(k\*n)，只要k不大，就近似于O(n)。




--- 

<div align="center">
	**本文作者**：王仁松
	仅供本人记录学习过程与学习交流之用，未经同意，禁止转载！
</div>