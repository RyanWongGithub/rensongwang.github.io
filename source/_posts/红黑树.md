---
title: 红黑树
tags:
  - 数据结构
categories:
  - 数据结构与算法
date: 2019-07-08 21:24:51
photo:
---

{% note default %}
红黑树在工程上使用特别广泛，为什么不采用AVL树这样更加稳定的数据结构？
{% endnote %}

<!-- more -->

## 树
树的一些概念：高度这么看，从下往上看，就是从叶子节点到指定结点的最大路径。深度从上往下看，从根节点到指定结点的最大路径。
- 结点高度，从叶子节点到指定结点的最大路径
- 结点深度，从根节点到指定结点的最大路径
- 树的高度，从叶子结点到根节点的最路径

## 二叉树
**完全二叉树**：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。
满二叉树：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点。

## 二叉查找树
二叉查找树对于数据在树上的存储有特定要求：
任意结点的左子树都要小于该结点，右子树都要大于该结点。

主要说一下二叉查找树的两点：
1. 二叉查找树的删除结点，删除一个结点时，如果该结点有左右子树，那么找到其右子树的最小结点（在最左边）替换该结点，然后删除最小结点。
2. 支持重复数据的二叉查找树：一种方法是，当插入数据时，遇到相同数据时，插入其右子树中，也就是当成大于该数据来处理。查找时遇到数据值相同时，不停止查找而是继续往下直到叶子结点。删除同理。

有如此高效的散列表，为什么还要用二叉查找树？
{% note success %}
总结以下：
- 散列表中的数据是无序的，想要有序输出，必须先排序，而二叉查找树只需要中序遍历即可
- 散列表存在散列冲突，也就是说，当发生散列冲突时，性能不稳定；而像AVL树这样的二叉查找树可以做到稳定
- 散列表的设计比较复杂，需要考虑的因素很多，比如装载因子、散列冲突、动态扩容等，而二叉查找树是比较成熟固定的解决方案
- 散列表的时间复杂度虽然可以做到O(1)，但是在发生散列冲突时，这个常量级时间复杂度可能并没有二叉查找树高效
- 从空间上来说，散列表为了避免散列冲突做出的牺牲比较大，特别是基于开放地址法的散列表会浪费一定的内存空间
{% endnote %}

## 红黑树
其实二叉查找树的出现就是为了高效的查找等操作。
但是在对二叉查找树进行频繁的动态插入、删除的操作时，可能会出现时间复杂度退化成链表O(n)的情况，很好想象，插入和删除的时候，数据全倒向一边。
 于是针对这种问题，我们设计了平衡二叉查找树（AVL树）。它的严格定义是：树中任意结点的左右子树的高度差不能大于1。

平衡二叉查找树是严格按照定义的。
但是我要讲的红黑树并不是十分按照这种严格定义的，但是红黑树也是一种平衡二叉查找树。
“平衡”指的就是整棵树看起来是左右平衡的，不会一边多一边少。
而**红黑树**就是做到了“近似平衡”。并不完全按照严格定义。
**红黑树的高度近似为2logn，插入、查找、删除的时间复杂度是O(logn)**。
红黑树的要求：
- 根节点是黑色的
- 任何相邻的结点都不能为红色的
- 每个结点，从该节点到达其可达叶子结点的所有路径，都包含相同数量的黑色结点
- 所有叶子节点都是黑色的NULL结点，不存储数据

## 为什么喜欢用红黑树
个人理解，用红黑树的本质其实是利用二叉查找树的特性。
但是二叉查找树有缺点，也就是可能会发生性能退化的情况。
像Treap、Splay Tree，效率很高，但是也无法避免极端情况下时间复杂度退化的情况。
又像AVL树这种高度平衡的二叉查找树，各方面性能很优秀，性能也十分稳定，但是AVL的稳定要化很大成本来维护，也就是说需要付出很大代价来维护AVL树的高度平衡。

**而红黑树只是做到了“近似平衡”，它维护平衡的代价上比AVL树要低，同时，性能也不会下降的很厉害**。





--- 

