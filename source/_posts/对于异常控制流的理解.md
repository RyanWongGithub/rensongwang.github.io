---
title: 对于异常控制流的理解
date: 2019-04-22 14:54:10
tags:
- 深入理解计算机系统
categories:
- CSAPP
photo:
---

{% note default %}
从处理器加电开始到断电，处理器假设一个值的序列：
a0,a1,a2,···,an-1
每个ak是某个指令Ik的地址，每次从ak到ak+1的过渡叫做控制转移。这样的控制转移序列叫做处理器的控制流。
控制流是平滑的，是指Ik和Ik+1在内存中是相邻的，平滑流的突变是指不相邻。
{% endnote %}

<!-- more -->


## 1. 异常控制流是什么呢
前面说到，对于平滑流的突变，可以是跳转、调用、返回等程序指令造成，**使得程序能够对由程序变量表示的内部程序状态中的变化做出反应**。
同样的，系统也必须能够对系统状态的变化做出反应。这些系统状态不是被内部程序变量捕获，也不一定和程序的执行相关。
比如：
1. 一个硬件定时器产生信号，这个事件必须处理
2. 包到达网络适配器后，必须放在内存
3. **程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪**
3. 当子进程终止时，创造这些子进程的父进程必须得到通知

现代系统通过使控制流发生突变来对上述情况做出反应。通常，我们将这些突变称为**异常控制流**。

## 2. 异常
异常就是控制流中的突变。
当处理器检测有事件发生时，它就会通过一张**异常表**的跳转表，进行一个间接过程调用（异常），到一个专门处理这类事件的操作系统子程序（异常处理程序）。
处理完成后，有三种情况：
1. 处理程序将控制返回给当前指令Icurr，即事件发生时正在执行的指令。
2. 将控制返回给Inext，即没有发生异常会执行的下一条指令。
3. 处理程序终止被中断的程序。

## 3. 异常处理
系统中可能的异常都分配一个非负**异常号**。
- 处理器设计者分配：被零除、缺页、内存访问违例。
- 操作系统内核分配：**系统调用**、来自外部I/O设备的信号。

前面讲过异常表，表目k包含异常k的处理程序的地址。

## 4. 异常与过程调用的不同之处
- 过程调用中，在跳转到处理程序之前，都要将返回地址压入栈中。而异常的返回地址要么是当前指令，要么是吓一跳指令
- 处理器也把一些额外的处理器状态压入栈中，在返回时，重新开始执行被中断的程序会需要这些状态
- <font color="red">**如果控制从用户程序转到内核，所有这些项目都被压入内核栈中，而不是用户栈中**</font>
- 异常处理程序运行在**内核模式下**，它们对所有的系统资源都有完全的访问权限

## 5. 异常的类别
异常有四类：**中断（interrupt）**、**陷阱（trap）**、**故障（fault）**和**终止（abort）**

| 类别 | 原因 | 异步/同步 | 返回行为 |
| :------: | :------ | :------: | :------ |
| 中断 | 来自I/O设备的信号 | 异步 | 总是返回到下一条指令 |
| 陷阱 | 有意的异常 | 同步 | 总是返回到下一条指令 |
| 故障 | 潜在可恢复的错误 | 同步 | 可能返回到当前指令 |
| 终止 | 不可恢复的错误 | 同步 | 不会返回 |

中断：中断为什么是异步的呢，怎么说呢，我一个程序在执行，执行得好好的，结果一个I/O设备信号来了，处理器就把我的控制夺走了，这就是中断，是异步的，因为不是我的错啊。我程序好好的，这个中断不是在我这个程序中造成的，所以叫**异步**。

陷阱：陷阱是有意的异常，是执行一条指令的结果。陷阱最重要的用途是：**系统调用**（在用户程序和内核之间提供一个像过程一样的接口）。
用户经常向内核请求服务，比如：
- 读一个文件read
- 创建一个新进程fork
- 加载一个新的程序execve
- 终止当前进程exit
从程序员的角度来看，系统调用其实和普通的函数调用是一样的。但是实现是非常不同。
普通的函数调用是运行在用户模式下，限制了函数可以执行的指令的类型，且只能访问与调用函数相同的栈。
**系统调用运行在内核模式中，允许特权指令，访问内核栈**。

故障：讲个例子吧，缺页，当指令引用一个虚拟地址时，与该地址相对应的物理页面不在内存中，这时候必须从磁盘取，发生故障，缺页处理程序从磁盘中加载适当的页面，然后将终止返回给引起故障的指令。这个时候重新执行该指令时，相应的页面已经在内存中，就不会再发生故障了。所以故障处理完了，还要重新执行。

终止：不可恢复的错误。

## 6. 进程
异常是允许操作系统内核提供进程概念的基本构造块。
经典定义：一个执行中程序的实例。
系统中的每个程序都运行在某个进程的上下文中。这个**上下文是由程序正确运行所需要的状态所组成的**，这些状态包括：
- 放在内存中的程序代码和数据
- 它的栈
- 通用目的寄存器的内容
- 程序计数器
- 环境变量
- 打开文件描述符的集合

进程提供给应用程序的关键抽象：
1. 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器
2. 一个私有地地址空间，它提供一个假象，好像我们的程序独占地使用内存系统

## 7. 逻辑控制流
实际上，就像我们之前在《为什么r=r*(x*(y*z))比r=r*x*y*z的执行效率更高》中讲到，处理器可以同时运行多条指令，不出意外的，
一个现代处理器也可以并发运行多个进程。
注意：并发并不是指同时执行！它的实现是靠我们下面要将的逻辑控制流

逻辑流呢，在这里不细讲，假如一个系统中同时运行着三个进程（这个同时不是真正意义上的同时，也就是说同一时刻并不是三个进程都在执行）。处理器的一个物理控制流被分成了三个逻辑流。
怎么去理解呢，比如：
一个处理器现在运行一个进程A，那么就处在A的逻辑流上。
这个时候A运行了一会，转到B运行开（到了B的逻辑流）。
B运行完了，C开始运行一会（C的逻辑流），转到A（A的逻辑流）。
A运行完了，最后到C（C的逻辑流）。
也就是说，进程的逻辑流是交错执行的，所以并不是同一时刻（严谨一点）运行。就像打印机，A打一会，换B，再换C······

## 8. 并发
终于到并发了，并发是啥呢，就是在我们清楚逻辑流的基础上，给出一个并发流的定义：
<font color="red">**一个逻辑流的执行时间在时间上与另一个流重叠了，就叫做并发流**</font>。
所以啊，并发啊并发，再次强调，并发不是并行，是A吃口饭，换B吃。A和B就是并发的。如果A吃完了，不吃了，这个时候C去吃。那么A的逻辑流在时间上和C没有重叠，那么A和C就不是并发的。

## 9. 私有地址空间
这个先不讲了，看图比较清晰。可是图好难画啊！多么想把书上的图扣下来。

## 10. 用户模式和内核模式
通过前面，我想已经大概知道了内核模式是个啥了吧。通常处理器是用某个控制寄存器中的一个**模式位**来提供这种功能。
没错，一个运行在内核模式中的进程可以干什么呢：
- 执行指令集中的任何指令
- 访问任何内存位置

没有设置模式位时，那就是用户模式啦，那受限的就多了：
- 不能执行特权指令：
停止处理器、改变模式位、发起一个I/O操作
- 不能直接引用地址空间中内核区的代码和数据

那我用户模式的进程怎么变为内核模式呢。**唯一方法**：
通过诸如中断、故障、陷入系统调用接口这样的异常。
过程：异常发生 -> 控制传递到异常处理程序（从用户态变成内核态）-> 运行在内核模式中 -> 返回到应用程序（从内核态变回用户态）

## 11. 上下文切换
前面讲到过上下文，这个上下文切换也就不难理解。它是内核来实现多任务，也就是并发的一种较高形式的异常控制流。
内核为每个进程都维护一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。

调度：内核决定抢占哪个，开始哪个，这就是调度。
当内核调度一个进程运行时，就抢占当前进程：
1. 保存当前进程的上下文
2. 恢复某个先前被抢占的进程被保存的上下文
3. 将控制传递给这个新恢复的进程

### 为什么要有上下文切换呢
这里真想放张图，一下子就理解了，后期吧。
1. 假如进程A在运行，也就是在用户态，直到遇到了read指令，那么这个时候就要发生系统调用请求。
在切换之前，内核正代表A在用户模式下执行指令（即没有单独的内核进程）。
2. 切换了，内核代表A在内核模式下执行指令（read，系统调用，内核中的陷阱处理程序请求来自磁盘的DMA传输）。
注意，这个时候，还不能执行下一条指令，因为磁盘的数据还没有传输到内存上，所以要等待。哪怕是几十毫秒，都很长了！
3. 所以内核执行A到进程B的上下文转换，切换为完成，这个时候内核就开始代表B执行指令（注意这个时候仍然是内核模式下），切换完成后，内核代表B在用户模式下执行指令。
4. B运行了一会，这个时候磁盘的数据到内存了，就发出一个中断信号。内核就判定B已经运行够了，执行一个B到A的上下文切换。
5. 将控制返回给A紧随在系统调用read后面那条指令，继续执行。

## 12.讲点fork和execve
详细于：原书P513-P525
fork要注意的就是：
1. <font color="red">**调用一次，返回两次**</font>。意思是什么呢。是在父进程中调用一次fork，在父进程中返回子进程的PID，这个时候子进程相当于是父进程的副本啊，但是注意只调用一次，所以子进程到对应fork函数的时候，不会再次调用，只会返回一个为0的PID，表示这是子进程！
2. **并发执行**。内核可能是任意方式交替执行它们的逻辑流。你根本不知道这个时间段中子进程先运行，还是父进程运行。
所以啊！<font color="red">不管有多少个fork，画个**进程图**解决一切输出问题的可能性！！！</font> 。
3. 相同但是独立的地址空间
4. 共享文件。如果父进程的输出指向屏幕，子进程继承了父进程所有的打开文件。如果调用fork函数的时候，stdout文件是打开的，并指向屏幕。那么子进程继承的时候，它的输出也是指向屏幕的。

execve：加载并运行程序。
注意：execve一旦成功执行了，就不会返回了，因为新程序会覆盖当前进程的地址空间，并没有创建一个新的进程。新的程序仍然有一个相同的PID，并且继承了调用execve函数时已打开的所有文件描述符。

## 13. 信号
通过前面，我们知道，操作系统可以利用异常来支持进程上下文切换的异常控制流形式。
Linux信号是一种更高层的软件形式的异常，它允许进程和内核中断其他进程。
为什么需要信号呢。因为底层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。
比如：如果一个进程试图除以0，那么内核就发送一个SIGFPE信号（号码8）给它。其余例子见 书P527

### 信号术语
- 发送信号。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号有两种原因：
1. 内核检测到一个系统事件，比如除零
2. 一个进程调用了kill函数，显示要求内核发送一个信号给目的进程
- 接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，就是接收了信号。
进程可以忽略这个信号，终止或执行一个称为**信号处理程序**的用户层函数捕获这个信号。

<font color="red">注意下面这段文字：</font> 
{% note default %}
一个发出而没有被接收的信号叫做待处理信号。**任何时候，一种类型至多只会有一个待处理信号**。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都不会排队等待；它们只是被简单地丢弃。
一个进程可以有选择性地**阻塞**接收某个信号，它仍然可以被发送，但是产生地待处理信号不会被接收，直到取消对这种信号地阻塞。
**一个待处理信号最多只能被接收一次**。
{% endnote %}
### 发送信号的方式
1. 用/bin/kill程序发送信号。一个为负的PID会导致信号被发送到进程组PID中的每个进程。
2. 从键盘发送信号（CTRL + C）
3. 用kill函数发送信号
4. 用alarm发送信号

### 接收信号
当内核把进程p从内核模式切换到用户模式时，会检查进程p的未被阻塞的待处理信号的集合。如果这个集合为空，内核将控制传递到p的逻辑控制流的下一条指令。如果非空，内核选择集合中的某个信号k，并强制p接收k。收到信号的会触发进程采取某种行为。

### 信号处理程序
详细于P535 8.5.5

正确的信号处理：
**信号的一个与直觉不符的方面是未处理的信号是不排队的**。
上面说过，每种类型最多只有一个待处理信号。如果两个类型为k的信号发送给一个目的进程，而因为目的进程当前正在执行信号k的处理信号程序，所以k信号被阻塞，那么第二个信号就简单被丢弃了，不会排队！
**所以，不要用信号来对其他进程中发生的事件计数！**

## 14. 非本地跳转
详细于：P546

后期会更新完善

--- 

<div align="center">
	**本文作者**：王仁松
	仅供本人记录学习过程与学习交流之用，未经同意，禁止转载！
</div>