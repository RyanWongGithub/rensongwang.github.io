---
title: 分配动态内存返回的指针就是与众不同？
tags:
  - 指针与内存
categories:
  - 指针与内存
date: 2019-08-21 10:21:12
photo:
---

{% note default %}
在写Web服务器的时候，为了动态增减工作线程的数量，而C里面我就不知道有什么动态数组，所以我就只能通过动态申请内存的方式来存储每一个线程tid，就在我操作时，由于我的不熟悉引发了一些错误，这些错误无非就是来源于对内存的操作不当，而像malloc和calloc等这些申请内存的函数还有free函数引起了我的注意，我在想，free只用传进去一个指针就能释放内存，但是我又没有告诉你大小，你怎么知道释放多大的内存？
{% endnote %}

<!-- more -->

# 首先得知道些什么，来点轻松的，以前没注意的

---

实际上不管是数组还是字符串，最后你存到内存上，那就是一块连续的内存空间，通过下标来随机访问，在C/C++中，访问内存必不可少的就是指针了。实际上，在以前，我就探究过，申请一个数组的数组名和一个相同类型的指针有什么区别。
**两者在访问数组元素上并没有什么区别，区别在于本身**，我个人认为（网上说法不一，这里说我自己的理解），数组名并不是一个常量指针，而且我个人更愿意去把它理解成**一个地址**，而事实上数组名有自己的类型，type[size]，这点可以利用typeid(var).name()去实践。
把数组名作为指针来讲实际上会让人产生很大的误会，至少我是脑袋没转过来。

首先，指针的概念都不用说，指针本身就是一个对象，也就是说，指针本身是有一个地址的，只不过指针这个变量在其所属地址上存放的是一个**地址值**。那如果数组名是一个指针，而数组名可以表示该数组首地址，那其本身地址在哪，是哪个？如果说是数组名这个指针存放的使其本身的地址，那么数组第一个元素放在哪？这其实本身就是**矛盾的**。
所以数组名绝不可能是一个指针。

那又如何去理解呢？如果对内存或者对这些变量常量的底层不是很了解，大可直接将其看成是数组首地址，也无需绕了。
其实很好理解，我们看看普通变量：
```
int a = 10;
```
那么这个int型对象a在底层是如何的呢？首先这个a有一个地址，然后在这个地址后面有4个字节大小的空间存放了10这个值。
系统如何找到a呢？实际上在程序变成进程这个过程中，a就与a的地址所关联了，我要知道a的值，我就按照这个地址取出地址上的内容就OK了。

类比于数组名：
```
int a[10];
```
**它也是一个对象，类型是int [10]**，然后也有个地址，这个地址就是**首地址**，然后在首地址后面有10 * 4个字节大小的空间用来存放10个int类型的值。用方括号取值，意思就是跑到对应地址上去一个int值。（当然其中是数组到指针隐式转换，但是个人认为不要这么理解为好）

指针对象：
```
int *p = a;
```
首先，刚刚也说了，指针本身有个地址，所以，单单看p，**它的值就是本身地址上的内容，只不过这个内容是一个地址值**。
所以说，给一个指针赋值，是给一个地址值放进去，因此，指针的用法就比普通对象要**多一个解引用符\***，**意思就是我要这个指针的内容（所指向地址）的内容（所指向地址上的内容）**。
因此为什么指针指向数组名，也就是数组首地址，也能够拥有和数组名一样的操作数组元素的效果了。

## sizeof：不是要求元素个数，人家的理想目标是内存大小
学到现在，我才发现自己以前真的很天真，sizeof是一个操作符，并不是一个函数，如果是一个函数比如strlen，倒有可能求出你数组或者字符串的大小（这个大小是指其中的元素个数），但是操作符并不会做过多的复杂的工作，人家的目标很单纯，就是内存空间大小。
**sizeof是C/C++中的一个操作符（operator），简单的说其作用就是返回一个对象或者类型所占的内存字节数。**
如果是一个对象，那么最后也是求这个对象的真正类型的内存字节数。
```
int a[10];
char b[10];
cout << sizeof(a) << " " << sizeof(b) << endl;
```
所以，这也是为什么sizeof(a)的值是40，sizeof(b)的值是10（char是一个字节）了，因为数组的类型就是type [size]啊。
**进一步证明上述我的观点**。

# 好了，开始标题的解答

---

开篇我们说了指针与内存，相信下面的就很好理解了（**我们简化指针是对象的本质，只看其所指的那个地址**）。我在Web服务器项目中用到了动态内存分配，在C中，有以下几种操作堆内存的函数。
```
void *malloc(unsigned int size)；
```
其作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址，或者说，此函数是一个指针型函数，**返回的指针指向该分配域的开头位置**。
但是malloc在分配内存的时候**不对其空间初始化**。

所以
```
void *calloc(size_t nmenb, size_t size); 
```
calloc最主要的还是将其空间进行初始化为0。

realloc:
```
extern void *realloc(void *mem_address, unsigned int newsize);
指针名=（数据类型*）realloc（要改变内存大小的指针名，新的大小）
```
1. 如果有足够空间用于扩大mem_address指向的内存块，则分配额外内存，并返回mem_address。
这里说的是“扩大”，我们知道，realloc是从堆上分配内存的，当扩大一块内存空间时， realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平。也就是说，如果原先的内存大小后面还有足够的空闲空间用来分配，加上原来的空间大小= newsize。那么就ok。得到的是一块连续的内存。
2. 如果原先的内存大小后面没有足够的空闲空间用来分配，那么从堆中另外找一块newsize大小的内存。
并把原来大小内存空间中的内容复制到newsize中，**原来的内存自动释放**。返回新的mem_address指针。（数据被移动了）。
老块被放回堆上。
咋一看，这不就是vector的模式吗？哈哈

注意，传递给realloc的指针必须是malloc或者是calloc分配之后返回的指针，至于为什么？为什么这么特别？
**这个必须是限定是指针的值，还是指针本身这个对象独一无二？，只能要你malloc返回的？**
答案是**是指针值，一开始给我搞的，我还以为指针还有多种呢，实际上，指针就是指针，上面那么说，是参考资料上和网上都这么说，在此，我认为，为了不引起误导，<font color="red">是那个指针值不能变</font>**。
为什么指针值不能变呢？请先看另一个问题。

你申请的动态内存相当于向系统租的，你用完了得还啊是不是？所以动态内存分配必须配套。
释放内存：
```
void free(void *ptr);
```
看到没，只需要传递一个指针就能释放内存，**我又没告诉你多大，你咋知道释放多大的内存？**
这得从我怎么租的开始说起：
{% note success %}
malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。
Linux Libc6采用的机制是在free的时候试图整合相邻的碎片，使其合并成为一个较大的free空间。
{% endnote %}
**实际上你得到的内存块大小要比你申请得大，因为每块内存的起始处首先要有这个结构：**
```
内存控制块结构定义
struct mem_control_block {

     int is_available;//是否是可用内存

     int size;//大小
};
```
也就是说，在返回指针之前，会将指针移动到这个结构体之后，然后返回，**所以在释放内存的时候，free会将指针值减去这个结构体大小，得到新的指针值，也就是我直接也得到了我该释放内存大小！**
是不是很巧妙。因此realloc也是这样的。
所以说，为什么越界很严重，因为你可能破坏下一块内存的内存控制块。

今天让我对于内存和指针有了新的认识和理解。

参考资料：
百度百科
<a href="https://www.cnblogs.com/li-hao/archive/2012/06/03/2532804.html">malloc()和free()的原理</a>




--- 

<div align="center">
	**本文作者**：王仁松
	仅供本人记录学习过程与学习交流之用，未经同意，禁止转载！
</div>