---
title: 浅谈文件系统
tags:
  - null
categories:
  - 操作系统个人理解系列
date: 2019-09-15 22:09:47
photo:
---

{% note default %}
文件系统真的研究起来，大而复杂，这里做一个简单的认识。
{% endnote %}

<!-- more -->
## 为什么要有文件系统？
一个计算机从开机到关机，不管运行什么样的进程，在内存中读写多少数据，最终都会呈现在磁盘上（或者一个固定的存储器上），不管数据多少，都需要管理保持一种秩序的存在。方便系统的正常运行。

## 文件系统需要满足什么要求？
1. 整齐划一的组织方式
2. 需要索引到方便查找
3. 需要文件夹的形式来方便管理和查询
4. 需要缓存层来方便热点文件的访问
5. 内核也需要一定的数据结构来存储打开文件的信息状态

## 磁盘文件系统如何实现？
实际上，在文件系统的设计上，进行了很多探索，比如顺序存储、链表存储等。
最终常用的还是**inode + 数据块的形式。**

**数据块**是什么呢？前面我们提到整齐划一的组织方式，磁盘也是一个一个扇区组成，每个扇区储存512字节（相当于0.5KB）。系统在读取磁盘的时候不能一个一个扇区的进行啊，这样子的效率实在是太低了，所以我们找到一个合适的大小，把磁盘直接划分成一个一个块的大小，来进行读取。

有了块还不够，我们得知道怎么快速找到每个块的具体位置在哪。
而一个文件在磁盘上又能被划分成许多的块，因此我们要找一个文件在磁盘上的具体位置，我们需要一个索引。
于是，每一个文件都有一个inode结构，i就是指的index，也就是索引的意思，可以看作是一个文件索引节点。
这个inode结构中就存放了这个文件的所有元数据（不包括文件名）。
```
struct ext4_inode {
	__le16	i_mode;		/* File mode */
	__le16	i_uid;		/* Low 16 bits of Owner Uid */
	__le32	i_size_lo;	/* Size in bytes */
	__le32	i_atime;	/* Access time */
	__le32	i_ctime;	/* Inode Change time */
	__le32	i_mtime;	/* Modification time */
	__le32	i_dtime;	/* Deletion Time */
	__le16	i_gid;		/* Low 16 bits of Group Id */
	__le16	i_links_count;	/* Links count */
	__le32	i_blocks_lo;	/* Blocks count */
	__le32	i_flags;	/* File flags */
......
	__le32	i_block[EXT4_N_BLOCKS];/* Pointers to blocks */
	__le32	i_generation;	/* File version (for NFS) */
	__le32	i_file_acl_lo;	/* File ACL */
	__le32	i_size_high;
......
};

```
大体上就是：
- 文件的字节数
- 文件拥有者的User ID
- 文件的Group ID
- 文件的读、写、执行权限
- 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。
- 链接数，即有多少文件名指向这个inode
- 文件数据block的位置

查看某个文件的inode信息
```
stat example.txt
```
## inode
对于一个文件系统来说，一般分为两个部分：
一个是数据区，存放文件数据，一个是inode区（inode table），存放文件的元数据。
一般来说，**inode是一个文件系统的有限资源**，也就是说，在文件系统（对一个分区格式化的时候）在初始化的时候，是定好了的。总数是确定的，而大小也是确定的。以为inode也需要空间来存储，如果太多的了，反而有点不合理了（我是要存数据滴）。

查看一个分区的inode总数和已使用情况。
```
df -i
```
查看每个inode节点的大小，可以用如下命令：
```
sudo dumpe2fs -h /dev/hda | grep "Inode size"
```
由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。**这也是无法生成一个文件的一个原因（创建一个文件出错）**。

## inode的组织方式
inode也是一堆数据，我找某个文件虽然可以通过inode找到，但是inode太多的化，我岂不是还是要一个一个inode的找。
针对这种情况，所有的inode也可以有一个数据结构来实现快速查找：**位图**。
也就是说，inode也是有编号的，123456这样子，那我都在一个位图中就可以通过1还是0就可以快速知道一个inode是不是被占用还是空闲的。
使用ls -i命令，可以看到文件名对应的inode号码：
```
ls -i example.txt
```
实际上，**数据块的位图 + 一系列数据块** 和**inode的位图 + 一系列inode**基本上就可以实现一个文件系统了，但是还是有问题。真正的文件系统是通过**块组**的形式组织起来的，后期更新。

## 目录也是文件
在linux中，一切皆文件，目录也不例外，只不过目录当中存的是一系列的目录项。
目录项：**文件名 + 文件对应的inode**。
ls -i命令列出整个目录文件，即文件名和inode号码：
```
ls -i /etc
```
如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。
```
ls -l /etc
```
由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。

## 硬链接和软链接
**硬链接**是指一个文件的别名。上面说inode的结构里面提到了一个inode的链接数，而硬链接指的就是多个文件的inode是同一个，也就是说，inode的链接数有很多个。
也就是说，删除了一个文件名，只是减少这个inode的链接数，当链接数为0的时候，才会真正删除这个文件，回收inode和数据块。
硬链接的一个缺点就是**不能跨文件系统**。

**软链接**本身是另外一个文件，有自己的inode，只不过这个inode指向的数据块中存放的是另一个文件的路径。
读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的"软链接"（soft link）或者"符号链接（symbolic link）。
**软链接指向的是文件名，而不是一个文件的inode，不会让其链接数加1。**
这意味着，软链接依赖于其指向文件，当指向文件删除之后，再打开这个软链接就会报错。
硬链接的一个优点就是**可以跨文件系统**。


--- 

