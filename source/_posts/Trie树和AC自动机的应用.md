---
title: Trie树和AC自动机的应用
tags:
  - 算法
categories:
  - 数据结构与算法
date: 2019-07-23 14:26:57
photo:
---

{% note default %}
我们日常在各大搜索引擎上搜索栏上进行搜索时，输入一个词，可能还不完整，自动下拉框就有补全的各种搜索词供我们选择。
在底层是通过Tire树实现的。
而于是我们在一些平台上与他人进行交流时，或者是发表言论时，如果输入的内容中包含一些敏感词汇，输出时会自动变成\*\*\*\*\*。
在底层其实是通过AC自动机实现的。
{% endnote %}

<!-- more -->
## 开始先说明
单模式串匹配算法是为了快速在主串中查找一个模式串，而多模式串匹配算法是为了快速在主串中查找多个模式
串

## Trie树
Tire树是一棵什么样的树，其实本质就是一棵多叉树，只不过，结点上存放的是一个词汇的某一个字符。
见图：
<img src="http://rensongwang.gitee.io/my_drawing_bed/Tire树.JPG">
根节点什么也不存，每个结点就表示字符串的一个字符，从根节点到红色结点的一条路径就是一个字符串（红色结点不一定是叶子节点）。

## 如何去构造一棵Tire树
从图片中我们就可以知道，实际上Tire树就是一棵多叉树，但是我们顺着路径下来查找字符串的过程中，我们需要很容易就找到各个孩子节点中我们需要的字符（结点）。
因此，我们可以将孩子结点的结构设计成类似于散列表那样，通过数组下标与字母对应，然后数组中存放孩子结点的下标来实现
```
class TrieNode {
 char data;
 TrieNode children[26];
}
```
这样，我们就可以很轻松的进行一个字符一个字符的查找了。

## Tire的内存消耗
从上面的实现方法，我们可以看出一些存在的缺点：如果我树中的孩子结点不多，也就是说我的叉不多，但是实现的时候还是要申请一个固定大小的对象数组来实现，会有比较大的内存消耗。
因此我们可以将节点中的数组换成其他数据结构，比如说有序数组，红黑树，跳表，散列表。这样牺牲了一点查找效率，但是比较好的节省了空间。
比如说，有序数组，我们查找一个孩子结点的时候，可以用二分查找。但是插入数据的时候，必须考虑有序性。

## Trie树是用来干嘛的？
其实，如果单纯用Tire树来进行某个字符串的查找，那么红黑树，或者之前的散列表都可以实现这样的功能，而且比Tire树要好。
怎么说呢？
- 用Tire树的话，空间可能会浪费严重
- 而且Tire树种包含的字符串的前缀重合必须多，不然也会浪费空间
- Tire树用到了指针串起来，对于缓存不友好，查找效率实际上有一定的影响。

那么Tire树到底是用来干嘛的，实际上Tire树在搜索匹配前缀上比较优秀，就像我们开头说的那样。

## AC自动机
AC自动机主要运用在敏感词过滤上，具体原理：
当用户输入一个文本内容后，我们把用户输入的内容作为主串，从第一个字符（假设是字符C）开始，在Trie树中匹配。当匹配到Trie树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位，也就是从字符C的下一个字符开始，重新在Trie树中匹配。

这就需要将多个敏感词构建成Tire树，因此AC自动机就是在Tire基础上做一些改进，就像BF与KMP的关系一样。

具体怎么改进呢？
类似于KMP，我们在Tire树上维护一个失败指针。
失败指针指向的就是**我们移动到哪**。是不是和KMP类似。
就连失败指针指向哪里的原理都与KMP类似。
见图易懂：
<img src="http://rensongwang.gitee.io/my_drawing_bed/Tire树失败指针原理.JPG">
假设我们沿Trie树走到p节点，也就是下图中的紫色节点，那p的失败指针就是从root走到紫色节点形成的字符串abc，跟所有模式串前缀匹配的最长可匹配后缀子串，就是箭头指的bc模式串。
这里的最长可匹配后缀子串，我稍微解释一下。字符串abc的后缀子串有两个bc，c，我们拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前 缀，那我们就把这个后缀子串叫作可匹配后缀子串。
我们从可匹配后缀子串中，找出最长的一个，就是刚刚讲到的最长可匹配后缀子串。我们将p节点的失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点，就是下图中箭头指向的节点。

## so
这样，我们在查找失败后，可以直接在Tire树种进行下一个敏感词的查找。效率很高，就像是KMP，哈哈。因为不用从头开始。
真的很像KMP！










--- 

