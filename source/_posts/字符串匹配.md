---
title: 字符串匹配
tags:
  - 算法
categories:
  - 数据结构与算法
date: 2019-07-23 13:14:45
photo:
---

{% note default %}
字符串匹配算法很常见，在实际开发中，用到的也多。
对于在一个长串中匹配一个模式串，我这里总结4种：
- BF
- RK
- BM
- KMP
BF和RK算法其实都是在主串中一个一个遍历，只是RK利用哈希算法优化了匹配过程。
BM和KMP都是在匹配失败之后寻找一种效率高的重新计算匹配开始位置的方法。BM要做的更极致，而KMP也十分优秀。
{% endnote %}

<!-- more -->

## BF
BF就是简单的：朴素匹配算法。
很好想象，就是拿模式串在主串一个字符一个字符的移动位置，去比较是否匹配，也就是说，如果匹配失败，就后移一个位置。
有点像滑动窗口的感觉。
时间复杂度是0(n\*m)，其中n是主串的长度，m是模式串的长度。
## RK
RK实际上也是滑动窗口的感觉，我认为只是在BF上改进了，改进在哪里呢？
改进了匹配的比较过程，在BF的匹配过程中，是拿模式串的每个字符去和主串中对应的字符一个一个比较，如果模式串的长度是m，那么依次匹配的比较过程的时间复杂度就是O(m)，如果主串长度是n的话，那么BF的总体匹配的时间复杂度就是O(n\*m)。
RK怎么去改进呢，就在于将一次匹配的比较过程的时间复杂度从O(m)降低到O(1)。
思路就是：
{% note success %}
利用哈希算法的思想，我们将主串中的每一个符合模式串长度的字串，分别求哈希值，然后再与模式串的哈希值进行比较，这样的时间效率就提高到O(1)。
{% endnote %}
但是这是依赖于哈希算法的设计，存在哈希冲突，设计不好，或者是数据的问题，都有可能造成时间复杂度退化的情况。

## BM
我认为BM和KMP都很类似于现实当中，我们人处理的方式，我们大脑去匹配字符串，可以直接在主串中搜索。也就是匹配失败的时候，大脑自动处理，就跳了很多位置，而不是像BF那样机械的处理。
BM是如何做到的呢？BM是从模式串的后面开始比较，依次到头
主要是两个规则：
- 坏字符规则
当主串中有字符与模式串中对应的字符不匹配时，我们就称这个在主串中的字符为“坏字符”。这个时候我们要移动模式串在主串中对应的位置去进行下一次匹配，怎么去移动呢？如果在坏字符在模式串中不存在，那么我们直接将模式串移动到主串中坏字符的后面一个位置即可。如果存在，我们就移动，让模式串中相等于坏字符的字符与主串中的坏字符进行对应。当然，如果存在多个，我们去最右边的就行对应。那么在算法中怎么计算呢？我们将匹配失败时，对应的字符的下标记为si，如果坏字符在模式串中存在，那么在模式串中对应字符的下标记为xi，不存在记为xi = -1。那我们下次要**移动位数就等于si-xi**。

- 好后缀规则
好后缀其实和坏字符类似，匹配失败时，坏字符前面肯定有已经匹配成功过的字符（BM是从后到前匹配），那就是好后缀，我们就要在模式串中找有没有好后缀。实际上，模式串中不存在好后缀，能与好后缀重合也行。

## KMP
KMP没有BM那么复杂，就是当发生字符串匹配失败时，我们通过特定方法重新计算移动位数。只不过这个方法没有BM那么复杂。
这个方法是通过next数组实现的。

当遇到坏字符的时候，我们就要把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀子串，
跟模式串的前缀子串在比较。这个比较的过程能否更高效了呢？可以不用一个字符一个字符地比较了吗？
KMP算法就是在试图寻找一种规律：在模式串和主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，能否找到一种规律，将模式串一次性滑动很多位？

**实际上next数组中存放的就是模式串的所有好前缀的对应的需要移动的位数。怎么去理解？也就是说，当发生匹配失败时，我前面肯定有好前缀吧（不一定）？我根据这个好前缀直接通过next数组算出需要移动的位数！**

那么next数组的原理是什么？其实只需要模式串本身就可以了，因为模式串的所有字串都有可能是好前缀，怎么去计算需要移动的位数呢？
就是**根据好前缀的最长匹配后缀字串对应的最长匹配前缀字串的结尾字符的下标来得到的！！！**

通俗的来讲，就是我看我的好前缀里有没有后缀字串与前缀字串匹配的情况，如果有，要最长的！！！










--- 

<div align="center">
	**本文作者**：王仁松
	仅供本人记录学习过程与学习交流之用，未经同意，禁止转载！
</div>