---
title: 对于消息认证以及数字签名的理解
tags:
  - InformationSafe
categories:
  - 信息安全
date: 2019-04-24 20:39:56
photo:
---

{% note default %}
其实涉及到信息安全，让我想起了讲二战时期图灵的那部电影，具体名字我忘了，不过主要讲的是，通过破解敌方机密，获取情报。关于加密解密的内容倒是挺有意思的。
在这里对于信息安全概论做一个小小的总结。
{% endnote %}

<!-- more -->
## 1. 信息安全的目标
1. 保密性
2. 完整性
3. 不可否认性
3. 可用性

## 2. 实现目标的技术和算法
密码理论：
是信息安全的基础，信息安全的保密性、
完整性和抗否认性都依赖于密码算法。包括数据加密
算法、数字签名算法、消息摘要算法及相应的密钥管
理协议等
这些算法提供两方面的服务：一方面，直
接对信息进行运算，保护信息的安全特征，即通过加
密变换保护信息的机密性，通过消息摘要变换检测信
息的完整性，通过数字签名保护信息的抗否认性；另
一方面，提供对身份认证和安全协议等理论的支持。

安全理论：
身份认证（Authentication）
授权和访问控制（Authorization and Access Control）
审计追踪（Auditing and Tracing）
安全协议（Security Protocol）

安全技术：
防火墙技术（Firewall）
漏洞扫描技术（Venearbility Scanning）
入侵检测技术（Intrusion Detection）
防病毒技术（Anti-Virus）

## 3. 信息安全的发展
经典信息安全：
基本思想（技巧）：代换和置换

现代信息安全
现代密码理论---A.Kerckhoffs---Shannon
第一阶段：1948年之前----密码技术是一种艺术
第二阶段：1949年---1975年---Communicaiton
Theory of Security System
第三阶段：1976年---至今---New Direction in
Cryptography

1977年密码学发生了两件大事：DES和公钥密码体制

## 4. 密码算法分类
按发展进程分：古典密码、对称密钥密码、公开密钥密码
按加密模式分对称加密算法又可分为：序列密码和分组密码

➢ 经典密码算法---代替
简单代替、多表代替、多字母代替等
➢ 经典密码算法---换位
➢ 对称加密算法---DES、AES
➢ 公钥加密算法---RSA、背包密码、Rabin、椭圆曲线等


对称加密呢，主要说说分组加密的原理，也就是把要加密的明文编码表示的信息进行分组，每个分组在密钥的控制下变换成等长的输出数字序列。每个明文分组应对应唯一一个密文分组。

DES加密算法：利用混乱和扩散，使得加密后的密文难以在计算上进行破解，同时又支持可逆运算，也就是说，我可以同一个密钥进行加密和解密。

公钥加密，不得不说，公钥的出现真的是使得密码学又进了一步，支持了数字签名，同时也使得密钥分配有了更多的可能性。
原理是什么呢。
通俗得讲，就是用两个不同得密钥来分别进行加密和解密，在对称密码体制中，双方必须先协商好通信密钥，而这样得过程并不是十分保险，而且对于保存密钥的问题也越来越明显，怎么说呢，如果A要和很多诸如B、C、D等等进行秘密通信，岂不是A要分别保存和这些人的共享密钥，人数多了你想想要保存多少密钥？毕竟人脑不是计算机。
可是公钥密码体制的出现解决了很多问题，因为A现在就只需要保存A自己的私钥，为什么呢，因为大家的公钥都公开了呀，你要和A我秘密通信，你就用我的公钥进行加密，完了发送给我，我收到了之后用我的私钥一解就OK了。

可是诸如RSA这样的公钥加密算法计算速度太慢了，效率还是没有对称密码体制高，以我个人的看法，我想这就是传统密码体制还在使用的原因吧，而且传统密码体制也有它存在的原因。
简要说一下RSA的过程：
RSA算法密钥生成过程：
1. 选择两个大素数p和q，需要使用素性检测方法；
2. 计算乘积n=pq和ϕ(n)=(p-1)(q-1)；
3. 选择大于1小于ϕ(n)的随机整数e，使得gcd(e,ϕ(n))=1；
4. 计算d使得de≡1modϕ(n)；
5. 确定公开密钥为{e,n}，私有密钥为{p,q,d}。
RSA算法的加密运算为C=M^e mod n，解密运算为M=C^d mod n。

## 消息认证和数字签名
<font color="red">**我想保密性已经解决了，但是完整性和不可否认性还是没有解决。
我先讲一下消息认证再说说我对于完整性的理解。
消息认证就是为了保证消息的完整性，通常就是通过散列函数的单向性来实现，在消息认证中，要保证X的散列H(X）没有另一个Y，Y的散列H(Y)等于H(X)，而且也不能通过H(X)推出X，那么如果说我现在是把我的X加上我的H(X)一起发给你，要是中途被他人恶意篡改，你收到后，分解，对X的部分进行散列，得到的H(X)肯定也就会和我发过来的H(X)不一样，这样，也就保证了我发送给你的消息没有被篡改过。
接下来你可能会想到，那么这肯定就是你吖的发过来的，没人能改呀。对，消息认证保证了完整性，但是消息认证和数字签名是两个东西，保证了消息的完整性，并不能保证不可否认性，要是A发给B的消息中途被C截获了，C干脆就不要X，H(X)了，他自己弄一个C，H(C)发给B，B这时候验证一下肯定是对的，那么B就认为C是A？**</font>

所以数字签名还是要用前面讲的公钥来解决，怎么签名呢，估计你已经想到了，我的私钥不是就我自己知道吗，我用我的私钥加密一下，发给你，你用我的公钥一解开，就能得到消息。而这样的签名，别人伪造不了，因为就只有我自己才有私钥。数字签名问题得到完美解决。

<font color="red">**那为什么数字签名还要和消息认证一起使用呢，在这里说一下我的两点理解：**
1. 数字签名保证不可否认性，但是不能保证完整性啊，怎么说呢，我保证了这个签名是我的，别人伪造不了，但是别人可以在中途截获了之后对我发送的消息进行破坏，那么接收端的你还是能用公钥解开，但是即使解开之后是一堆乱码你也不能保证是不是被人篡改了，万一我就是发乱码给你呢？
2. 通常来说，说RSA算法的效率较慢，如果我要签名的信息很长，那么岂不是我每次签名都要费很长的时间，那么这时候消息认证的散列就起了作用，想MD5等这样的消息认证算法，能够将任意长度的消息输入，输出固定长度的H，那么每次我签名就只用签名固定长度，提高了效率。</font>

## 密钥分配过程中，中间人的攻击
Merkle密钥分配体制的流程为：
1. 用户A生成公私钥对{KUa,KRa},并向用户B发送A的身份和KUa；
2. 用户B生成随机密钥KS，并使用KUa加密KS后发送给A；
3. 用户A使用KRa解密后获得KS；
4. 用户A和B双方丢弃公私钥对{KUa,KRa} 。
Merkle密钥分配体制在通信前后均不存在密钥，其可以抵御窃听，但不能抵御中间人攻击。
Merkle密钥分配的中间人攻击流程为：
1. 用户A生成公私钥对{KUa,KRa}，并向用户B发送A的身份和KUa；
2. 攻击者E截获该消息，生成公私钥对{KUe,KRe}，冒充A，向B发送A的身份和KUe；
3. 用户B生成随机密钥KS，并使用KUe加密KS后发送给A；
4. 攻击者E截获该消息，使用KRe解密后获得KS，并使用KUa加密KS后发送给A；
5. 用户A使用KRa解密后获得KS；
6. 用户A和B双方丢弃公私钥对{KUa,KRa}。
至此，攻击者E已获得会话密钥KS，之后仅需窃听即可获得双方通信消息，而A和B并不知
道他们已经遭受了攻击。

Diffie-Hellman密钥交换协议为：
1. 用户A和B双方选定素数q和q的一个小于q的原根α；
2. 用户A随机选择小于q的自然数XA，计算YA≡α^XA mod q后将其发送给B；
3. 用户B随机选择小于q的自然数XB，计算YB≡α^XB mod q后将其发送给A；
4. 用户A计算K≡YB^XA≡α^XBXA mod q；
5. 用户B计算K≡YA^XB≡α^XAXB mod q。
至此双方获得了共享密钥，但这种协议不能抵御中间人攻击。
Diffie-Hellman密钥交换协议的中间人攻击流程为：
1. 用户A和B双方选定素数q和q的一个小于q的原根α；
2. 用户A随机选择小于q的自然数XA，计算YA≡α^XA mod q后将其发送给B；
3. 攻击者E截获该消息，随机选择小于q的自然数X1，计算Y1≡α^X1 mod q后将其发送给B；
4. 用户B随机选择小于q的自然数XB，计算YB≡α^XB mod q后将其发送给A；
5. 攻击者E截获该消息，随机选择小于q的自然数X2，计算Y2≡α^X2 mod q后将其发送给B；
6. 用户A计算K2≡Y2^XA≡α^XAX2 mod q；
7. 用户B计算K1≡Y1^XB≡α^XBX1 mod q；
8. 攻击者E计算K2≡YA^X2≡α^XAX2 mod q，K1≡YB^X1≡α^XBX1 mod q。
至此，攻击者E已获得共享密钥，之后用发送方密钥解密所截获消息后用接收方密钥加密即
可在A和B不知道他们已经遭受了攻击的情况下获取消息。在增加数字签名的情况下，共享密钥
可得到验证，中间人攻击也将不能奏效。




--- 

<div align="center">
	**本文作者**：王仁松
	仅供本人记录学习过程与学习交流之用，未经同意，禁止转载！
</div>