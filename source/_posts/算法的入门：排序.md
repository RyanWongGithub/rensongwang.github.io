---
title: 算法的入门：排序
tags:
  - 算法
categories:
  - 数据结构与算法
date: 2019-05-15 10:55:24
photo:
---

{% note default %}
怎么样才能叫做是算法呢，其实，以我个人理解，能够解决实际问题的一系列方法都能叫做算法，而这个方法并没有限制是哪一种。
其实最开始接触编程的时候，必不可少的就会认识到一些简单的算法，就像解一道题一样，写一个思路，把方法写上去，得出正确答案。
所以算法，并没有想象的那么难。
真正能称得上难的是什么呢，是这道题很难，一般人解不出来，而想出来的大佬的算法，你一看你能看懂，但是，让你去想出来就不是那么容易。
所以算法，到最后，体现的是一个人的智商。
实际问题中，排序应该是最基本的。也符合人类的思考。
在这里做一个对于排序算法的理解和总结。
{% endnote %}

<!-- more -->

## 首先，得要清楚时间复杂度和空间复杂度
### what
时间复杂度和空间复杂度是什么呢？
我们通俗地认为，时间复杂度就是一个算法执行下来所需要的时间，这个其实很好理解，A想的算法解决问题需要很长时间，而别人B的算法解决问题时间很短，实际用谁的算法（单从时间复杂度考虑）当然是用B的。
这里需要注意的就是时间复杂度通常是用类似于O(n)这种形式，实际上这种形式往往忽略了常数系数。
举个例子，一个规模为n的问题，时间复杂度是关于n的，那么像n^3+n^2+2345这种时间复杂度，我们往往忽略常数和低阶，只关注最高阶n^3，那么时间复杂度也就是O(n^3)。
当然，问题就是，n很大的时候我们可以这么做，那n较小，怎么办？

### why
{% note default %}
所以，我们往往，在设计算法的时候，要考虑很多情况，就比如数据规模不同的时候，这个算法的时间复杂度是不是就一定比其他的算法的时间复杂度更好呢？
在后面，这是一个值得思考的问题。同时通过这样的分析，我们也可以多方面去考虑我们的算法，也可以多个角度去思考问题。
**从而达到一种不断优化算法的目的，这个在实际开发中是非常重要的**
**因为一个算法不仅仅是要能够解决问题而已**
{% endnote %}

空间复杂度，简单来讲，就是执行一个算法需要用到的空间，也就是这个算法的内存消耗。后面具体讲算法，会更有体会。

## 通过排序算法来具体分析
### 首先，很重要的是，对一个算法要提几个问题
1. 最好、最坏、平均时间复杂度各是多少
2. .时间复杂度的系数、常数 、低阶
3. 元素比较次数和交换（或移动）次数

### 还有特别重要的是
1. 排序算法的内存消耗
内存消耗其实就是空间复杂度的体现
2. **{% label warning@排序算法的稳定性 %}**
排序算法的稳定性我觉得有两个方面：
- 最好、最坏、平均时间复杂度都是一样的，也就是说，无论面对什么样的数据，都可以以一个**稳定的时间复杂度**来完成。
- 第二个就是普遍讲的**稳定性**
怎么去理解呢，个人的一个很好的理解方法就是结合情景去理解：
<u>A</u>和A是两个相同（具体以某一种排序条件来看）的元素，如果在使用某一个排序算法前，它们的相对位置是<u>A</u>在前，在使用算法排序之后，它们的位置变成了A和<u>A</u>
A在前了，也就是说，两个相同的元素的相对位置发生了改变。这就是不稳定的。

## 简单的3种时间复杂度为O(n^2)的排序算法
下面我简单记录一下算法的思路与简单实现代码，后续优化会更新。
主要是根据上面的问题来解答对应的思考问题。

### 冒泡排序
冒泡排序，顾名思义，就是冒泡，哈哈。
n个元素我进行n-1趟
每一趟都是从数组第一个元素开始，将它与后一个元素进行比较，如果反序就交换，否则不动。
那我遍历一遍，就可以把这一堆无序的数据里面最大的元素交换到最后面。

那么，冒泡排序的最好、最坏、平均时间复杂度各是多少呢？
- 最好时间复杂度
{% note danger %}
其实冒泡的最好时间复杂度这里可以做到O(n)，为什么说可以呢，因为算法没有优化过，会是O(N^2)。
怎么优化做到O(n)：如果一个数组基本有序，那么我遍历一遍都没有进行过交换元素的操作，那我直接退出循环。时间复杂度就是O(n)。
{% endnote %}

- 最坏时间复杂度
这个应该不用分析了，O(N^2)

- 平均时间复杂度
平均时间复杂度就是加权平均期望时间复杂度，具体不详细说明。
O(N^2)










--- 

<div align="center">
	**本文作者**：王仁松
	仅供本人记录学习过程与学习交流之用，未经同意，禁止转载！
</div>