---
title: 排序-冒泡插入选择
tags:
  - 算法
categories:
  - 数据结构与算法
date: 2019-07-01 09:12:33
photo:
---

{% note default %}
最常规的时间复杂度为O(n^2)的三种算法的C++编程实现，加上一点原理介绍和一些注意点总结。
最为重要的我觉得还是个人的一些理解和总结，和亲自测试这些算法的运行效率。
{% endnote %}

<!-- more -->

## 排序-冒泡插入选择
冒泡插入选择这三种排序算法是比较简单的。
分析时间复杂度就简化。这里只是做一些简单的总结。重点是实践编程。

## 冒泡
冒泡的原理就是一趟排序中将数组中最大的元素找出来，放在最后面。
这就涉及到了比较和元素交换。
需要注意的地方就是冒泡排序的优化。
优化也就是在于，我们要排的数据基本上有序了，那么一趟冒泡下来，也就没有必要继续了。对应最好的情况：O(n)
所以在这里我们要设置一个跳出循环的炸弹。
具体代码：
```
void booSort(int *arr, int size)
{
	for (int i = 0; i < size - 1; i++)//因为只比较n-1趟
	{
		bool bre = false;//设置炸弹开启
		for (int j = 0; j < size - i - 1; j++)//每次比较的次数-1，并且j只走到最后一个元素的前面一个元素
		{
			int tmp = arr[j];
			if (arr[j] > arr[j + 1])//每次都和后面的元素进行比较，大于后面的元素就和后面的元素进行交换
			{
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
				bre = true;//关闭炸弹
			}
		}
		if(!bre)//只要一趟下来没有交换的操作，那么直接退出循环，完成排序
		{
			break;
		}
	}
}
```
在实际运行中，10000个在范围为10的随机数的排序时间为34812ms左右，范围100000，时间为37157ms左右
## 插入
插入的原理就是，将无序区的元素插入到有序区，主要就是插入的方法与过程。
这里分析平均时间复杂度的时候，可以这么想，往数组里插入一个元素的时间复杂度是O(n)，我排序基本上要插n个数据。
于是平均时间复杂度为O(n^2)。
它最好情况也是O(n)，因为每次插的时候，跟有序区最后一个元素比较的时候，已经大于之，所以都不用插。
具体代码：
```
void insertSort(int *arr, int size)
{
	for (int i = 1; i < size; i++)//无序区初始为n-1个元素， 有序区初始为第一个元素，所以从1开始。
	{
		int tmp = arr[i];//把无序区的要排序的元素存在tmp里面。
		int j = i - 1;//j就是要排序的元素的前面一个元素。因为这里插入是从尾到头开始比较。
		for (; j >= 0; j--)
		{
			if (tmp < arr[j])
			{
				arr[j + 1] = arr[j];//这里，只要前面的元素大于要排序的元素，我就后移元素。但是我先不管最前面那个元素的值，因为最后被tmp覆盖即可。
			}
			else
			{
				//这里就相当于炸弹爆炸
				break;//只要不小于前面的元素，我就不比较了，这时候的j就是我要插入的位置前面的一个元素。
			}
		}
		arr[j + 1] = tmp;//在终止之后，插在前面一个元素的后一个位置。
	}
}
```
在实际运行中，10000个在范围为10的随机数的排序时间为12094ms左右，范围100000，时间为13750ms左右
插入没有特别需要注意的地方，但是优化的话--》希尔排序

## 选择
选择没有特别的地方。
选择有点像冒泡和插入的组合，但是谁都不像，谁都不如。
但是有一点需要注意的就是，我最开始的版本是每次一出现比头小的就交换位置。正确的版本应该是
一出现更小的，记录值和位置。最后才交换。所以下面有两个版本
```
void checkSort(int *arr, int size)
{
	//头。每次我都要选出最小的放在最前面。最后就是最后一个元素前一个元素的位置
	for (int i = 0; i < size - 1; i++)	
	{
		int head = arr[i];//把头位置的数据保存到head里面
		for (int j = i + 1; j < size; j++)//直接从头后面一个元素开始
		{
			
			if (arr[j] < head)//只要我头后面的元素更小的话，我就跟头进行交换。
			{
				int tmp = arr[j];
				arr[j] = head;
				head = tmp;//就不断更新头数据，保证头数据是无序区中最小的
			}
		}
		arr[i] = head;//完了之后头数据写入头位置
	}
}
```
在实际运行中，10000个在范围为10的随机数的排序时间为9532ms左右，范围100000，时间为17718ms左右
```
//选择2
void checkSort2(vector<int> &ivec, int n)
{
	int head = 0;
	int jj = 0;
	int tmp = 0;
	for (int i = 0; i < n - 1; i++)
	{
		head = ivec[i];
		
		for (int j = i + 1; j < n; j++)
		{
			if (ivec[j] < head)
			{
				head = ivec[j];//这里只记录值和位置
				jj = j;
			}
				

		}
		if (head != ivec[i])//这里应该是只要有比头小的才交换，没有就不交换
		{
			tmp = ivec[i];
			ivec[i] = head;
			ivec[jj] = tmp;
		}
		


	}
}
```
在实际运行中，10000个在范围为10的随机数的排序时间为9453ms左右，范围100000，时间为9328ms左右

总结：
1. 一般在冒泡和插入排序中，我们都选择插入排序。这是因为插入排序中，比较元素之后，并不直接进行元素的交换，只涉及到移动。只需要执行一条语句。而冒泡排序每次比较完之后满足条件必然要进行交换。交换就要执行三条语句。
在实际运行中，插入比冒泡要快。
但是，不知道为什么选择在上述测试条件中是最快的。而且两个版本的选择的效率相差并不大。














--- 

