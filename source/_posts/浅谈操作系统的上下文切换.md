---
title: 浅谈操作系统的上下文切换
tags:
  - null
categories:
  - 操作系统个人理解系列
date: 2019-09-15 10:26:17
photo:
---

{% note default %}
以前对于什么用户态和内核态之间的切换、进程与进程之间的切换总有些模糊，在这里好好梳理一下。
{% endnote %}

<!-- more -->

## 前言
在此先说明，在操作系统底层对于各种各样的上下文切换有着很复杂的实现细节，这里抛去大部分的细节，讲个大概。

## 内核态和用户态
一开始系统运行时，要先初始化内核。先是0号进程，再是1号，2号（所有内核线程的祖先）。
而1号进程是所有用户进程的祖先进程。
而1号进程是用户进程，这就涉及到最开始内核态和用户态的切换（一般来说，都是先有用户态，再陷入内核态再回到用户态，怎么一开始就从内核态到用户态呢？下面会讲）。

为什么会有内核态和用户态？
我们应该知道实模式对于操作系统来说只是来启动系统时用的，想要办大事还是要在保护模式下。
而保护模式除了能够运行更大的程序之外，最重要的一个作用就是“保护”。
保护是指，用户进程和内核进程有一个明显的权限划分。
x86提供了分层的权限机制。
把区域分成了4个权限。越往里，权限越高。分别是Ring 0、1、2、3。
一般来说，内核是运行在Ring 0下，而用户进程运行在Ring 3下。
0是最高权限，也就是说能访问计算机的所有资源。
所以，**能访问关键资源的代码放在Ring 0，我们称为内核态，而普通的程序代码放在Ring 3，称为用户态。**

那么用户态怎么去访问计算机的那些资源呢？
**只能通过内核态去访问，也就是我们常说的陷入内核（系统调用）。**
那系统调用是什么呢？个人理解，通俗的讲，就是提供给用户进程访问操作计算机资源的一系列接口。

## CPU上下文切换
接着讲，陷入内核就意味着，在用户态代码执行的好好的，一下子要转到内核态代码去执行，我这摊子都摆好了，你让我换地方。
为了从内核回来还能继续正常执行，**很重要的一点就是保存当前的运行状态。也就是将在用户态运行的状态全部保存起来**。然后CPU的控制单元中的段寄存器指向内核态中代码中的代码段、数据段、栈段等；各种寄存器指针指向内核态代码。
这就是**CPU上下文切换**。

这个过程就是这样的：用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态，然后接着运行。

## 系统调用
当然系统调用实际上真正的过程十分复杂。这里只是讲个大概。
32位系统和64位系统的系统调用过程是不一样的。这里大概讲一下32位系统的系统调用。

## 中断
在讲系统调用之前，得先说明一下，**中断的概念**。
中断分为同步中断和异步中断。异步中断就是我们常说的**中断**。实际上，最终的本质是，系统运行中的**异常控制流**。
通俗的讲，就是我的指令一条一条执行的好好的，现在突然让我转到另外一个地方去执行另外一条指令。

同步中断：陷阱、故障、终止。
异步中断：中断。

陷阱就是我们常说的类似于系统调用之类的。故障举个例子就是缺页中断之类的。而中断是指设备发送的信号。

**内核在初始化时，trap_init()里卖弄设置了很多的中断门，用于处理各种中断。其中有一个 set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32)，这是系统调用的中断门。**

## 系统调用的过程
在系统调用之前，我们将请求参数放在寄存器里面，**根据系统调用的名称，得到系统调用号**，放在寄存器**eax**	里面，然后执行**ENTER_KERNEL**。
这个ENTER_KERNEL是个啥呢？
```
#	define	ENTER_KERNEL	int	$0x80
```
int	就是	interrupt，也就是“中断”的意思。int	$0x80（告诉CPU）就是触发一个软中断，通过它就可以陷入（trap）内核。
上面说的trap_init()，系统调用的陷入门：
```
set_system_intr_gate(IA32_SYSCALL_VECTOR,	entry_INT80_32);
```
这是一个软中断的陷入门。当接收到一个系统调用的时候，entry_INT80_32就被调用了。
```
ENTRY(entry_INT80_32)
ASM_CLAC
pushl		%eax	       /*	pt_regs->orig_ax	*/
SAVE_ALL	pt_regs_ax=$-ENOSYS				/*	save	rest	*/
movl				%esp,	%eax
call				do_syscall_32_irqs_on
.Lsyscall_32_done:
......
.Lirq_return:
INTERRUPT_RETURN
```
通过	push和SAVE_ALL将当前用户态的寄存器，保存在**pt_regs结构**里面。
进入内核之前，保存所有的寄存器，然后调用do_syscall_32_irqs_on。这里我就不继续贴代码了，后面工作了细细研究。
主要的实现就是，从eax里面取出系统调用号，通过这个号在系统调用表中找到对应的系统调用函数，并讲寄存器中保存的参数取出来。

那么怎么回去呢？
当系统调用结束之后，在 entry_INT80_32 之后，紧接着调用的是 INTERRUPT_RETURN，我们能够找到它的定义，也就是 iret。
```
#define INTERRUPT_RETURN iret
```
iret 指令将原来用户态保存的现场恢复回来，包含代码段、指令指针寄存器等。这时候用户态进程恢复执行。
这里配一张图，特别清晰：
<img src="http://rensongwang.gitee.io/my_drawing_bed/CPU上下文切换.JPG">

## 回到开篇
什么是上下文切换呢，其实上下文切换指的是多种上下文切换，平时我们经常说的就是进程上下文切换，线程上下文切换。
其实说到最细还是，CPU上下文切换，其实CPU上下文切换发生在各种地方，一个进程陷入内核会发生CPU上下文切换，进程/线程切换会发生上下文切换。
一般来说，上下文切换指的是进程/线程切换。而内核态用户态之间的切换虽然也涉及到CPU上下文切换，但是只在一个进程内；一般叫做**模式切换。**

上下文切换实际上涉及到很多东西。不管是进程切换还是线程切换，到了内核，统一都是任务切换，进程和线程都是任务，统一由一个task_struct的数据结构管理，另外每一个进程都有一个进程控制块，记录着进程运行的所有状态信息，所以在进行进程切换的时候，往往在CPU上下文切换过程中，就会涉及到进程上下文的保存和恢复；以及任务调度。


--- 

