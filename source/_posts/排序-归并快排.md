---
title: 排序-归并快排
tags:
  - 算法
categories:
  - 数据结构与算法
date: 2019-07-01 09:19:01
photo:
---

{% note default %}
归并和快排在实际开发过程中用到很多，归并呢，在处理大数据量不能同时放入内存进行处理的情况下十分有效。
而快排呢，虽然时间复杂度不稳定，算法本身也不是稳定的排序算法，但是却没有像归并那样有一个致命的弱点：非原地排序。
下面给出我个人实现归并和快排的编程代码。
包括我个人的对于原理的理解和总结；以及测试算法的效率。
{% endnote %}

<!-- more -->


## 归并
其实，归并和快排都涉及到分治思想。
在现实生活中我们也常常遇到这种类似问题。
就是把一个很难解决的大问题分解成小问题。通过把一个一个小问题解决。再返回结果。从而解决大问题。
类似，分治思想的核心就是不断拆分问题，直到不能拆分为止，通过解决小问题来解决最后的大问题。

没错，递归就很适合这种类似问题，也符合人的思维。
但是，我们怎么通过递归去写这个归并算法呢？
首先，写递归代码有三步：
1. 写出递推公式
2. 终止条件（不能一直递归下去）
3. 翻译成代码

其次，归并排序的核心是，将一个待排序的数组分成两部分，两部分分成四部分，最终排序两个元素（最后也可能只剩一个元素），再将各个部分依次**合并**上去。

接下来我们写递推公式：
merge_sort(p...r) = merge(merge_sort(p...q),merge_sort(q+1...r))
终止条件：
p>=r//不用继续分解
翻译成代码（全部代码）：
```
//归并
//归并的插排
void merge_insertSort(vector<int> &ivec, int p, int q)
{
	if (p == q)
	{
		return;
	}
	for (int i = p + 1; i <= q; ++i)
	{
		int tmp = ivec[i];
		int j = i - 1;
		for (; j >= p; --j)
		{
			if (tmp < ivec[j])
			{
				ivec[j + 1] = ivec[j];
			}
			else
			{
				break;
			}
		}
		ivec[j + 1] = tmp;
	}
}
//归并的合并函数，在合并函数中对分好的小组进行插排，这个时候对小部分排序已经是对常量级排序。
void merge(vector<int> &ivec, int p, int q, int r)
{
	//先对传进来的两个数组分别插排
	merge_insertSort(ivec, p, q);
	merge_insertSort(ivec, q + 1, r);
	//再合并
	vector<int> tmp;//临时数组
	int i = p, j = q + 1, k = r;
	while (i <= q && j <= r)
	{
		if (ivec[i] <= ivec[j])
		{
			tmp.push_back(ivec[i]);
			++i;
		}
		else
		{
			tmp.push_back(ivec[j]);
			++j;
		}
	}
	//把剩余的全放进tmp里面
	if (i > q)
	{
		for (; j <= r; ++j)
		{
			tmp.push_back(ivec[j]);
		}
	}
	else
	{
		for (; i <= q; ++i)
		{
			tmp.push_back(ivec[i]);
		}
	}
	//把tmp拷贝到ivec里面
	int size = tmp.size();
	for (int i = 0; i < size; i++)
	{
		ivec[p + i] = tmp[i];
	}
}
//归并的递归函数
void merge_sort_c(vector<int> &ivec, int p, int r)
{
	//终止条件
	if (p >= r)
	{
		return;
	}
	int q = (p + r) / 2;
	//其实下面这个判断可做可不做，做了就少陷入一次递归（函数调用）
	if (q == p)
	{
		return;
	}
	merge_sort_c(ivec, p, q);
	merge_sort_c(ivec, q+1, r);
	//合并
	merge(ivec, p, q, r);
}

void merge_sort(vector<int> &ivec, int n)
{
	//调用递归函数
	merge_sort_c(ivec, 0, n - 1);
}
```
我在这里解释一我的做法。
merge_sort就是归并算法的入口。进去之后直接调用递归函数，这里需要注意的是我将代表size的n传给递归函数的时候，意义就变成了**下标**。
递归函数的作用并不是概念上的那么大，在代码中实际上只起到了分解下标的作用，也就是把一个数组的下标继续划分。
真正起作用的是，合并函数，在合并函数当中就做了核心的东西。

归并的一个要点是，将**已经有序**的数组合并。
但是递归函数只是划分，并没有排序。所以这个还是要在合并函数中合并之前做排序。
这里我是自己根据这个算法的特点（传递的是下标）设计了一个插排（其实改动不大）。
这里可能你会想，归并里面用插排？那时间复杂度岂不是？···
时间复杂度还是O（n\*logn)，这是因为**分治**，我们一直划分，到最后我们要用插排-排序的数组已经是常量级的了。

这里还有一点就是，归并排序的稳定性取决于合并函数。怎么去思考。
在划分的时候，不管有没有序，数组中的元素的相对位置是确定的。
所以我们在合并的时候，先拿前面的数组与后面的数组进行比较，如果**小于等于**，注意这个条件，小于等于的话，那么我们划分之后相对在前面的数组里的元素与后面位置的数组的元素相等的情况下，我们还是将处于前面位置的元素放在前面。
可能有点绕，我们看代码：
```
while (i <= q && j <= r)
	{
		if (ivec[i] <= ivec[j])//这里优先前面的数组的元素，如果写成<，那么就不稳定了
		{
			tmp.push_back(ivec[i]);
			++i;
		}
		else
		{
			tmp.push_back(ivec[j]);
			++j;
		}
	}
```


在实际运行中，10000个在范围为10的随机数的排序时间为391ms左右，范围100000，时间为391ms左右
实践证明，归并排序的时间复杂度的稳定性很好，排序的效率与数据的排列无关。

## 快排
快排也是分治的思想，但是，快排很巧妙的运用了分区的思想。
在一组无序的数组中选一个分区点，然后根据这个分区点，小于它的放左边，大于它的放右边。
然后把分区按照这个方法再分成两个子分区。最后区间为1终止。

递推公式：
quick_sort(p...r) = quick_sort(p...q-1) + quick_sort(q+1...r)//q就是分区点。
终止条件：
p>=r

转换成代码：
```
//快排的分区函数（真正实现排序）。这里主要用原地分区方法（不多做交换的那种）
int partition(vector<int> &ivec, int p, int r)
{
	//j是遍历工作游标，i是分区游标，i的左边是小于分区点的，i的右边是大于分区点的（包括i）
	int i = p, j = p;

	int md = (p + r) / 2;
	int fin = 0;
	//三个取一个中间值作为分区点。还有一种方法就是随机取值。
	if ((ivec[p] < ivec[r]) && (ivec[p] < ivec[md]))
	{
		if (ivec[md] < ivec[r])
		{
			fin = md;
		}
		else
		{
			fin = r;
		}
	}
	else if ((ivec[p] > ivec[r]) && (ivec[p] > ivec[md]))
	{
		if (ivec[md] > ivec[r])
		{
			fin = md;
		}
		else
		{
			fin = r;
		}
	}
	else
	{
		fin = p;
	}
	//取好分区点之后，放到数组最后面。
	int tmp = ivec[r];
	ivec[r] = ivec[fin];
	ivec[fin] = tmp;
	//分区点放好之后开始原地分区
	for (; j < r; j++)
	{
		if (ivec[j] < ivec[r])
		{
			int tmp = ivec[j];
			ivec[j] = ivec[i];
			ivec[i] = tmp;
			++i;
		}
		
	}
	//最后把分区点跟i分区游标交换
	int tmp2 = ivec[r];
	ivec[r] = ivec[i];
	ivec[i] = tmp;
	
	return i;

}
//快排的递归
void quick_sort_c(vector<int> &ivec, int p, int r)
{
	if (p >= r)
	{
		return;
	}
	//获取分区点
	int q = partition(ivec, p, r);
	quick_sort_c(ivec, p, q - 1);
	quick_sort_c(ivec, q + 1, r);
}

void quick_sort(vector<int> &ivec, int n)
{
	quick_sort_c(ivec, 0, n - 1);//直接给的是下标
}
```
{% note danger %}
在写二分的时候发现快排排序不是完全正确的！哈哈，不仔细看真看不出来，包括上面的代码实现里面我也没有改。
记录在这里，问题出在原地分区函数最后，分区点与i分区游标交换那里。粗心了！
{% endnote %}
在实际运行中，10000个在范围为10的随机数的排序时间为1953ms左右,范围100000，时间为125ms左右

快排的核心是它的分区函数。
一般来想，最简单的就是两个临时数组去存储两个子分区。但是那样的话就不是原地排序了。
所以我们要做到原地分区。
原地分区很巧妙，也挺有意思的。（放到现实当中也易想象）
当然原地分区也有不同的版本，有好坏。在这里我只说优化比较好的一种。（分区点的选取优化为三个点选中间值）
**分区点放在数组最后面**
我的理解是这样的：
1. 有两个游标，一个i，一个j。
2. i是分区游标，意思就是，i左边的都是**（小于分区点的元素）**，i右边的包括i都是**（大于分区点的元素）**。
3. j是工作游标，意思就是，j不断遍历，处理一个就加一。
4. 具体运行的时候，就是j不受影响，处理一个加j++，但是i就会根据j遍历到的元素的值是否小于分区点而变化；
5. 最开始，i，j都指向第一个元素。比较j指向的元素与分区点，小于分区点，i就加一，也就是向后移动一位（指向下一位元素），代表的就是i前面的元素小于分区点。这个时候，j指向下一个元素，进行比较，如果大于，i不动，j继续后移。
直到出现了比分区点小的元素，这个时候**将j指向的元素与i指向的元素交换**。i加一，j继续后移。
<font color="red">**核心就是分区游标i，这里总结，就是只要j指向的元素小于分区点，那么将j指向的元素与i指向的元素交换，i后移一位**</font>，具体见代码。
6. 最后，j移到了分区点，**我们可以设置小于才交换**，那么就遍历完了。i前面的都是小于分区点的。
7. 这个时候，把分区点所在的位置上的元素与i位置的元素进行交换，就完成了一次原地分区。

需要注意的就是，核心就是，**j指向的元素比分区点小，我们就与i指向的元素交换，i游标加1**。
具体见上面的代码。

## 总结
虽然归并和快排都用到了分治的思想。
但是，其实看代码，我们就发现，它们的区别就在于：
- 归并解决问题是自下向上的。
- 快排解决问题是自上向下的。

其实很好理解，归并在排序的时候，先不断缩小要排序的区间，最后才对小区间排序，然后合并。
而快排呢，在不断分区之前，就已经在解决问题。因为你要确定分区点，那么你肯定先要分区，在分区的过程中其实已经在排序了。
{% note info %}
- 归并排序的效率与数据无关
- 但是快排的效率会被要排序的数据的有序程度影响。从上面的测试数据我们就可以看出，如果数据范围为10的话，10000个数是比较有序的，而数据范围为100000，快排的效率是所有排序算法中最高的！
{% endnote %}












--- 

